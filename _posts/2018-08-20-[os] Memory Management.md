---
title: "Memory Management"
categories: os
excerpt: "Memory Management"
---



컴퓨터는 cpu에서 논리주소를 읽고 실제 물리주소로 변환하는 작업을 한다.

연속 할당 방식과 페이징 기법, 세그먼테이션 기법을 알아보자



## 연속 할당 방식

프로그램을 구성하는 가상 메모리를 MMU를 통해 변화되어 통째로 할당되는 방식이다. 비교적 간단한 방식이다.

![memoryconvert](/images/os/memoryconvert.png)

할당되는 과정에서 내부 단편화와 외부 단편화가 발생할 수 있다.

* First-fit : Size가 n 이상인 것 중 최초로 찾아지는 hole에 할당 -> 가장 빠르다.
* Best-fit : Size가 n 이상인 가장 작은 hole을 찾아 할당 -> 정렬되지 않는 경우 시간이 오래걸림
* worst-fit : 가장 큰 hole에 할당







## 불연속 할당 방식 (paging)

**paging** : 프로세스를 일정 크기(4kb)의 페이지로 나누어 메모리에 할당하는 방식이다. 모든 페이지가 동일하기 때문에 빈 페이지(4kb) 보다 프로세스의 페이지(4kb)가 더 커서 발생하는 외부 단편화가 생기는 일은 없다. 하지만 프로세스가 4kb로 나누어 떨어지는 것을 보장할 수는 없기 때문에 내부 단편화가 발생할 가능성은 존재한다. (예를들어 마지막 페이지가 2kb를 차지할경우 2kb만큼의 내부 단편화가 생긴다.)



페이징은 MMU대신에 페이지 테이블이 그 역할을 한다.

프로세스의 논리적인 메모리는 페이지로 구성되어있고, 페이지 테이블을 통해 물리적 메모리의 어디에 할당되어 있는지 알 수 있다.



cpu는 페이지 테이블과 offset을 가지고 페이지 테이블을 참조하여 실제 주소를 찾는다.



페이지 테이블은 메모리에 상주하고 있다. 만약 해당 페이지에 접근을 하려면 페이지 테이블과 실제 데이터의 접근하므로 총  2번의 접근을 한다. 때문에 속도향상을 위해 **TLB(Translation Look-aside Buffer)**라는 lookup 하드웨어 캐시를 사용하여 주소변환을 빠르게 한다.

* 페이지 테이블의 일부는 TLB캐시에 담아두고 cpu는 페이지 테이블에 접근하기 전에 TLB를 확인하고 있으면 실제 데이터에 접근한다.(메모리 1번 접근) 하지만 TLB에 없다면 똑같이 페이지 테이블에 접근하고 실제 데이터에 접근한다.(메모리 2번 접근)
* TLB는 병렬적인 접근이 가능해서 페이지가 TLB에 존재하는지 검사하는 속도는 매우 빠르다.
* 프로세스가 context switch가 발생할때 TLB는 초기화된다.



### 2 Level Page Table

page테이블을 한 단계로만 쓰면 주소공간의 낭비가 매우 크기 때문에  2단계로 페이지를 구성한다.

32비트 컴퓨터에서 하나의 프로세스는 2^32 크기 (4GB) 를 가질 수 있고, 4KB의 페이지로 나누게 되면 백만개의 페이지로 구성된다. 만약 하나의 페이지 테이블을 사용한다면 페이지 테이블의 크기는 백만 x 4B = 4M 의 크기를 가지게 된다. 즉, 각각의 프로세스는 4M의 페이지 테이플을 가지게 되므로 낭비가 매우 심하다고 할 수 있다.

하지만 실제 프로세스의 메로리중 대부분의 공간은 사용하지 않는 공간일 수 있다. 하나의 페이지 테이블 엔트리만 사용한다면 사용되지 않는 부분도 비워둘 수 없다. 왜냐하면 나중에 사용하려고 할때 접근할 수 없기 때문이다. 2단계 페이지 테이블 기법은 사용하지 않는 부분은 outer-page table에 NULL로 셋팅하고 inner-page table에는 만들지 않으면 된다. 그렇게 되면 페이지 테이블의 크기를 크게 절약할 수 있다.

![2levelpage](/images/os/2levelpage.png)

![2levelpage](/images/os/2levelpage2.png)

32비트 컴퓨터의 2단계 페이지의 logical address는 다음과 같이 구성된다.

| page number1 | page number2 | page offset |
| :----------: | :----------: | :---------: |
|      10      |      10      |     12      |

* 4KB 페이지에서 몇번째 offset인지 구분하는 page offset은 몇 비트로 4KB를 구분할 수 있는지를 의미한다. 4KB = 2^12 이므로 12비트를 사용해서 구분이 가능하다.
* page number2는 physical memory의 몇번째 프레임에 페이지가 위치하고 있는지를 의미한다. 즉 주소를 의미하므로 각 엔트리는 4B이다. 페이지 테이블 하나의 크기는 4KB이므로 4KB / 4B = 1K = 2^10 이므로 10비트를 사용해서 구분이 가능하다.
* page number1은 총 32비트에서 (12 + 10) 을 뺀  10을 의미한다.



이런 방식을 활용하여 다단계 페이지를 만들게 되면 공간을 크게 절약할 수 있지만 접근시간은 더 오래 걸린다는 단점이 있다.

**사실 프로세스에서는 극히 일부분의 페이지만 사용한다고 한다. TLB를 활용하면 다단계 페이지 기법을 사용해도 TLB Hit율이 높기때문에 높은 속도를 유지한다고 한다.*







## Segmentation

페이징 기법이 프로세스를 동일한 크기로 나누어 관리하는것과 다르게 세그먼테이션 기법은 의미단위(코드/데이터/스택)의 세그먼트로 나누어 구성한다.

세그먼테이션 기법도 페이징과 비슷하게 주소변환을 한다. 하지만 세그먼테이션은 페이지와 다르게 크기가 일정하지 않기 때문에 세그먼트 테이블에는 물리주소의 프레임 번호와 함께 limit값도 담고 있다.

![segmentation](/images/os/segmentation.png)

장점 :

- 보안 - 의미 단위로 구성되어 있기 때문에 접근권한을 통째로 줄 수 있어서 보안에 유용하다. (페이지는 코드 영역과 데이터 영역이 페이지의 크기만큼 딱 떨어지는 보장이 없기 때문에 힘들다)
- 공유 - 의미 단위로 구성되어 있기 때문에 같은 부분을 공유하기 쉽다.



단점 :

- 세그먼트의 크기가 제각각이기 때문에 외부 단편화가 발생하여 메모리 낭비가 크다.

- 세그먼트의 구성이 많지 않기 때문에 현실적으로는 세그먼트기법을 사용하는 경우는 거의 없다.



### Segmentation with Page

페이지와 세그먼테이션을 혼합하여 사용한다.

두가지 기법의 장점을 살리고 단점을 극복한 방법이다.