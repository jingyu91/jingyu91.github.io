<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-08-22T10:57:58+09:00</updated><id>http://localhost:4000/</id><title type="html">Jingyu playground</title><subtitle></subtitle><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><entry><title type="html">Virtual Memory</title><link href="http://localhost:4000/os/os-Virtual-Memory/" rel="alternate" type="text/html" title="Virtual Memory" /><published>2018-08-20T00:00:00+09:00</published><updated>2018-08-20T00:00:00+09:00</updated><id>http://localhost:4000/os/%5Bos%5D%20Virtual%20Memory</id><content type="html" xml:base="http://localhost:4000/os/os-Virtual-Memory/">&lt;h1 id=&quot;가상메모리&quot;&gt;가상메모리&lt;/h1&gt;

&lt;p&gt;가상메모리는 실제 메모리가 아닌 가상의 메모리를 관리하는 방법으로 멀티태스킹 운영체제에서 실제 메모리보다 큰 메모리를 제공 할 수 있다. 어느 시점에서 프로세스가 사용되는 부분은 일부분이며, 페이징이나 세그먼테이션 기법을 사용하여 실질적으로 필요한 부분만 메모리에 올려준다. 그러면 cpu는 연속적으로 메모리에 데이터를 가지고 있는것처럼 착각하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;demanding-page&quot;&gt;Demanding Page&lt;/h2&gt;

&lt;p&gt;실제로 필요할때 page를 메모리에 적재하는것&lt;/p&gt;

&lt;p&gt;현재 사용되는 부분은 물리 메모리에 올라와 있고 나머지 페이지는 &lt;strong&gt;backing store(swap area)&lt;/strong&gt;에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/pageReplacement.png&quot; alt=&quot;pageReplacement&quot; /&gt;&lt;/p&gt;

&lt;p&gt;페이지 테이블에 valid / invalid 비트를 두어 현재 물리 메모리에 올라와 있음을 체크한다. valid로 체크되어 있는 논리 주소는 바로 실제 주소로 변환된다. 하지만 invalid에 체크가 되어 있으면 MMU가 트랩을 발생 시키게 된다(&lt;strong&gt;“page fault”&lt;/strong&gt;). 이때 운영체제는 backing store에서 해당 페이지를 momory로 읽어온다(disk io). 이 후에 페이지 테이블에서 해당 페이지를 valid로 체크하고 다시 프로세스에게 cpu를 이양하여 작업을 계속하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/pageReplacement2.png&quot; alt=&quot;pageReplacement2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;page-replacement-algorithm&quot;&gt;Page replacement Algorithm&lt;/h2&gt;

&lt;p&gt;page fault가 발생하였는데 현재 메모리에 빈 공간이 없을 경우가 있다.&lt;/p&gt;

&lt;p&gt;page replacement algorithm은 어떤 프레임을 내쫒을지 결정하는 알고리즘으로 page-fault rate를 줄이는 것이 관건이다.&lt;/p&gt;

&lt;h3 id=&quot;optiaml-algorithm-최적-알고리즘&quot;&gt;Optiaml Algorithm (최적 알고리즘)&lt;/h3&gt;

&lt;p&gt;미래에 어떤 페이지가 올지 미리 알고 있는것을 가정한 것으로 가장 효율적인 알고리즘이다.&lt;/p&gt;

&lt;p&gt;실제로는 불가능하기 때문에 성능 측정용으로 사용한다.&lt;/p&gt;

&lt;p&gt;ex) 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;=&amp;gt; 6번 page fault 발생&lt;/p&gt;

&lt;h3 id=&quot;fifo-algorithm&quot;&gt;FIFO Algorithm&lt;/h3&gt;

&lt;p&gt;먼저 들어온 것을 먼저 내쫒는다.&lt;/p&gt;

&lt;h3 id=&quot;lru-least-recently-used-algorithm&quot;&gt;LRU (Least Recently Used) Algorithm&lt;/h3&gt;

&lt;p&gt;가장 오래전에 참조된 것을 내쫒는다.&lt;/p&gt;

&lt;p&gt;과거에 그 페이지가 자주 참조되었는지는 고려하지 않는다.&lt;/p&gt;

&lt;p&gt;가장 많이 사용되는 알고리즘 중 하나이다.&lt;/p&gt;

&lt;p&gt;ex) 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;=&amp;gt; 8번 page fault 발생&lt;/p&gt;

&lt;p&gt;LinkedList를 사용하여 구현하여 한줄로 세운다. 새로 참조되는 노드는 가장 줄의 가장 마지막으로 이동시키고 page fault가 발생할 경우 가장 첫 노드를 내쫒으면 된다. 시간복잡도 : O(1)&lt;/p&gt;

&lt;h3 id=&quot;lfu-least-frequently-used-algorithm&quot;&gt;LFU (Least Frequently Used) Algorithm&lt;/h3&gt;

&lt;p&gt;가장 적게 참조된 것을 내쫒는다.&lt;/p&gt;

&lt;p&gt;과거에 페이지의 빈도수를 계산하여 우선순위를 매긴다.&lt;/p&gt;

&lt;p&gt;LinkedList를 사용하여 구현하게되면 새로 참조되는 노드부터 마지막 노드까지 비교하여 이동시키기 때문에 O(n)의 시간 복잡도가 된다. 하지만 Heap을 사용하여 구현하면 O(logN)가 된다.&lt;/p&gt;

&lt;h3 id=&quot;clock-algorithm&quot;&gt;Clock Algorithm&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/clockAlgorithm.png&quot; alt=&quot;clockAlgorithm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;페이지들의 reference bit를 CirecularLinkedList로 구현하고 사용될때 1로 셋팅한다. bit를 1로 바꾸는 것은 하드웨어의 지원을 받고 0으로 바꾸는 것은 운영체제가 한다. 시계바늘이 한바퀴 돌면서 1인것은 0으로 셋팅하여 다음 방문까지 한번 더 기회를 주고 0인경우 페이지를 쫒아낸다. 내용이 수정된적이 있으면 modified bit(=dirty bit)을 1로 셋팅하여 1이면 디스크로 쫒아낼때 디스크 내용도 바꿔준다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*reference bit (= access bit) : 1은 최근에 사용됨, 0은 사용되지 않음&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;클럭 알고리즘은 NUR(Not Used Recently), NRU(Not Recently Used)라고도 불린다.&lt;/p&gt;

&lt;h2 id=&quot;thrashing&quot;&gt;Thrashing&lt;/h2&gt;

&lt;p&gt;메모리에 프로세스가 여러개가 올라와있는 경우 cpu utilization이 상승한다. 하지만 계속해서 프로세스가 메모리에 올라가게 되어 메모리의 한계치까지 도달하게 된다면 page-fault가 일어나기 시작한다. 결국에는 cpu가 일을 제대로 하지 못하고 페이지 교체만 처리하느라 cpu 이용률이 급격히 떨어지게 된다. 이와 같은 현상을 &lt;strong&gt;Thrashing&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;locality-of-reference&quot;&gt;Locality of reference&lt;/h3&gt;

&lt;p&gt;프로세스는 특정 시점에서 일정 장소만을 집중적으로 참조한다.&lt;/p&gt;

&lt;p&gt;집중적으로 참조되는 page들의 집합을 locality set이라고 한다.&lt;/p&gt;

&lt;p&gt;다음은 스레싱을 방지하는 알고리즘이다.&lt;/p&gt;

&lt;h3 id=&quot;working-set-model&quot;&gt;Working-set Model&lt;/h3&gt;

&lt;p&gt;한꺼번에 메모리에 올라와 있어야 하는 page의 집합을 &lt;strong&gt;working-set&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;Thrashing을 예방할 수 있다.&lt;/p&gt;

&lt;p&gt;현재 시점에서 n개의 과거페이지를 워킹셋으로 두고 메모리에 유지한다. page-fault가 발생하여 쫒겨날 경우 통째로 쫒겨나고 메모리에 올라올경우 워킹셋을 보장할 수 있을때만 통째로 올라온다.&lt;/p&gt;

&lt;h3 id=&quot;pff-page-fault-frequency&quot;&gt;PFF (Page Fault Frequency)&lt;/h3&gt;

&lt;p&gt;프로세스가 처음 시작되면 페이지폴트가 계속해서 발생하여 페이지 부재율이 매우 높다. 이 후에 어느정도 메모리에 페이지를 할당받으면 페이지 부재율은 낮아지게 되며 곡선을 그리며 내려오게 된다. 즉, 초반에는 페이지 부재율이 급격히 낮아지다가 점점 감소율이 적어지게 된다. PFF는 가장 효과적인 구간을 유지하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;페이지 부재율의 상한과 하한을 정하고 상한을 넘으면 frame을 더 할당하고 하한값 이하이면 할당 frame 수를 줄인다.&lt;/p&gt;

&lt;h2 id=&quot;page-size의-수&quot;&gt;Page Size의 수&lt;/h2&gt;

&lt;p&gt;페이지 사이즈를 감소시킬때 장단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 수 증가&lt;/li&gt;
  &lt;li&gt;페이지 테이블 크기 증가&lt;/li&gt;
  &lt;li&gt;내부 단편화 감소&lt;/li&gt;
  &lt;li&gt;page-fault시 더 많은 디스크io가 발생함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최근에는 큰 페이지 사이즈를 가지려고 하는 편이다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">Virtual Memory</summary></entry><entry><title type="html">Memory Management</title><link href="http://localhost:4000/os/os-Memory-Management/" rel="alternate" type="text/html" title="Memory Management" /><published>2018-08-20T00:00:00+09:00</published><updated>2018-08-20T00:00:00+09:00</updated><id>http://localhost:4000/os/%5Bos%5D%20Memory%20Management</id><content type="html" xml:base="http://localhost:4000/os/os-Memory-Management/">&lt;p&gt;컴퓨터는 cpu에서 논리주소를 읽고 실제 물리주소로 변환하는 작업을 한다.&lt;/p&gt;

&lt;p&gt;연속 할당 방식과 페이징 기법, 세그먼테이션 기법을 알아보자&lt;/p&gt;

&lt;h2 id=&quot;연속-할당-방식&quot;&gt;연속 할당 방식&lt;/h2&gt;

&lt;p&gt;프로그램을 구성하는 가상 메모리를 MMU를 통해 변화되어 통째로 할당되는 방식이다. 비교적 간단한 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/memoryconvert.png&quot; alt=&quot;memoryconvert&quot; /&gt;&lt;/p&gt;

&lt;p&gt;할당되는 과정에서 내부 단편화와 외부 단편화가 발생할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;First-fit : Size가 n 이상인 것 중 최초로 찾아지는 hole에 할당 -&amp;gt; 가장 빠르다.&lt;/li&gt;
  &lt;li&gt;Best-fit : Size가 n 이상인 가장 작은 hole을 찾아 할당 -&amp;gt; 정렬되지 않는 경우 시간이 오래걸림&lt;/li&gt;
  &lt;li&gt;worst-fit : 가장 큰 hole에 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;불연속-할당-방식-paging&quot;&gt;불연속 할당 방식 (paging)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;paging&lt;/strong&gt; : 프로세스를 일정 크기(4kb)의 페이지로 나누어 메모리에 할당하는 방식이다. 모든 페이지가 동일하기 때문에 빈 페이지(4kb) 보다 프로세스의 페이지(4kb)가 더 커서 발생하는 외부 단편화가 생기는 일은 없다. 하지만 프로세스가 4kb로 나누어 떨어지는 것을 보장할 수는 없기 때문에 내부 단편화가 발생할 가능성은 존재한다. (예를들어 마지막 페이지가 2kb를 차지할경우 2kb만큼의 내부 단편화가 생긴다.)&lt;/p&gt;

&lt;p&gt;페이징은 MMU대신에 페이지 테이블이 그 역할을 한다.&lt;/p&gt;

&lt;p&gt;프로세스의 논리적인 메모리는 페이지로 구성되어있고, 페이지 테이블을 통해 물리적 메모리의 어디에 할당되어 있는지 알 수 있다.&lt;/p&gt;

&lt;p&gt;cpu는 페이지 테이블과 offset을 가지고 페이지 테이블을 참조하여 실제 주소를 찾는다.&lt;/p&gt;

&lt;p&gt;페이지 테이블은 메모리에 상주하고 있다. 만약 해당 페이지에 접근을 하려면 페이지 테이블과 실제 데이터의 접근하므로 총  2번의 접근을 한다. 때문에 속도향상을 위해 &lt;strong&gt;TLB(Translation Look-aside Buffer)&lt;/strong&gt;라는 lookup 하드웨어 캐시를 사용하여 주소변환을 빠르게 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 테이블의 일부는 TLB캐시에 담아두고 cpu는 페이지 테이블에 접근하기 전에 TLB를 확인하고 있으면 실제 데이터에 접근한다.(메모리 1번 접근) 하지만 TLB에 없다면 똑같이 페이지 테이블에 접근하고 실제 데이터에 접근한다.(메모리 2번 접근)&lt;/li&gt;
  &lt;li&gt;TLB는 병렬적인 접근이 가능해서 페이지가 TLB에 존재하는지 검사하는 속도는 매우 빠르다.&lt;/li&gt;
  &lt;li&gt;프로세스가 context switch가 발생할때 TLB는 초기화된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-level-page-table&quot;&gt;2 Level Page Table&lt;/h3&gt;

&lt;p&gt;page테이블을 한 단계로만 쓰면 주소공간의 낭비가 매우 크기 때문에  2단계로 페이지를 구성한다.&lt;/p&gt;

&lt;p&gt;32비트 컴퓨터에서 하나의 프로세스는 2^32 크기 (4GB) 를 가질 수 있고, 4KB의 페이지로 나누게 되면 백만개의 페이지로 구성된다. 만약 하나의 페이지 테이블을 사용한다면 페이지 테이블의 크기는 백만 x 4B = 4M 의 크기를 가지게 된다. 즉, 각각의 프로세스는 4M의 페이지 테이플을 가지게 되므로 낭비가 매우 심하다고 할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 실제 프로세스의 메로리중 대부분의 공간은 사용하지 않는 공간일 수 있다. 하나의 페이지 테이블 엔트리만 사용한다면 사용되지 않는 부분도 비워둘 수 없다. 왜냐하면 나중에 사용하려고 할때 접근할 수 없기 때문이다. 2단계 페이지 테이블 기법은 사용하지 않는 부분은 outer-page table에 NULL로 셋팅하고 inner-page table에는 만들지 않으면 된다. 그렇게 되면 페이지 테이블의 크기를 크게 절약할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/2levelpage.png&quot; alt=&quot;2levelpage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/2levelpage2.png&quot; alt=&quot;2levelpage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;32비트 컴퓨터의 2단계 페이지의 logical address는 다음과 같이 구성된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page number1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page number2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page offset&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;4KB 페이지에서 몇번째 offset인지 구분하는 page offset은 몇 비트로 4KB를 구분할 수 있는지를 의미한다. 4KB = 2^12 이므로 12비트를 사용해서 구분이 가능하다.&lt;/li&gt;
  &lt;li&gt;page number2는 physical memory의 몇번째 프레임에 페이지가 위치하고 있는지를 의미한다. 즉 주소를 의미하므로 각 엔트리는 4B이다. 페이지 테이블 하나의 크기는 4KB이므로 4KB / 4B = 1K = 2^10 이므로 10비트를 사용해서 구분이 가능하다.&lt;/li&gt;
  &lt;li&gt;page number1은 총 32비트에서 (12 + 10) 을 뺀  10을 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 방식을 활용하여 다단계 페이지를 만들게 되면 공간을 크게 절약할 수 있지만 접근시간은 더 오래 걸린다는 단점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*사실 프로세스에서는 극히 일부분의 페이지만 사용한다고 한다. TLB를 활용하면 다단계 페이지 기법을 사용해도 TLB Hit율이 높기때문에 높은 속도를 유지한다고 한다.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;segmentation&quot;&gt;Segmentation&lt;/h2&gt;

&lt;p&gt;페이징 기법이 프로세스를 동일한 크기로 나누어 관리하는것과 다르게 세그먼테이션 기법은 의미단위(코드/데이터/스택)의 세그먼트로 나누어 구성한다.&lt;/p&gt;

&lt;p&gt;세그먼테이션 기법도 페이징과 비슷하게 주소변환을 한다. 하지만 세그먼테이션은 페이지와 다르게 크기가 일정하지 않기 때문에 세그먼트 테이블에는 물리주소의 프레임 번호와 함께 limit값도 담고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/segmentation.png&quot; alt=&quot;segmentation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;장점 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;보안 - 의미 단위로 구성되어 있기 때문에 접근권한을 통째로 줄 수 있어서 보안에 유용하다. (페이지는 코드 영역과 데이터 영역이 페이지의 크기만큼 딱 떨어지는 보장이 없기 때문에 힘들다)&lt;/li&gt;
  &lt;li&gt;공유 - 의미 단위로 구성되어 있기 때문에 같은 부분을 공유하기 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단점 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;세그먼트의 크기가 제각각이기 때문에 외부 단편화가 발생하여 메모리 낭비가 크다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;세그먼트의 구성이 많지 않기 때문에 현실적으로는 세그먼트기법을 사용하는 경우는 거의 없다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;segmentation-with-page&quot;&gt;Segmentation with Page&lt;/h3&gt;

&lt;p&gt;페이지와 세그먼테이션을 혼합하여 사용한다.&lt;/p&gt;

&lt;p&gt;두가지 기법의 장점을 살리고 단점을 극복한 방법이다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">Memory Management</summary></entry><entry><title type="html">Process Synchronization</title><link href="http://localhost:4000/os/os-Process-Synchronization/" rel="alternate" type="text/html" title="Process Synchronization" /><published>2018-08-13T00:00:00+09:00</published><updated>2018-08-13T00:00:00+09:00</updated><id>http://localhost:4000/os/%5Bos%5D%20Process%20Synchronization</id><content type="html" xml:base="http://localhost:4000/os/os-Process-Synchronization/">&lt;h2 id=&quot;race-condition&quot;&gt;race condition&lt;/h2&gt;

&lt;p&gt;공유자원에 대해서 여러 프로세스가 동시에 접근하는 상황을 말한다.&lt;/p&gt;

&lt;p&gt;사용자 프로그램 혹은 커널에서 공유 메모리에 있는 자원을 사용하다가 시스템콜 혹은 인터럽트가 발생하여 
다른 작업을 실행하는데 이전에 사용하던 자원을 사용하게 되면 일관성을 해치게 된다.&lt;/p&gt;

&lt;p&gt;예를들어 공유데이터 x가 있는데 프로세스 A는 &lt;code class=&quot;highlighter-rouge&quot;&gt;x = x + 1;&lt;/code&gt;  명령을 수행하고, 프로세스 B는 &lt;code class=&quot;highlighter-rouge&quot;&gt;x = x -1&lt;/code&gt; 명령을 수행한다.&lt;/p&gt;

&lt;p&gt;사실 컴퓨터에서는 저 명령어 한줄을 원자적으로 한번에 처리할 수 없다.&lt;/p&gt;

&lt;p&gt;실제로는&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reg1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;reg1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reg1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이런식으로 처리를 하게 되는데 A의 명령어 수행중  B의 인터럽트로 x를 변경하는 경우 일관성이 깨지는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;critical-section-problem&quot;&gt;Critical Section Problem&lt;/h2&gt;

&lt;p&gt;위 예제처럼 공유데이터를 접근하는 부분을 &lt;strong&gt;critical section&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;~~~&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// critical section
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~~~&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;u&gt;critical section&lt;/u&gt;을 피하는 방법을 소프트웨어적으로 해결하기 위해선 다음과 같은 원칙을 만족시켜야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Mutual Exclusion (상호배제) : 동시에 진입할 수 없다.&lt;/li&gt;
  &lt;li&gt;Progress (진행) : 진행이 안된다.&lt;/li&gt;
  &lt;li&gt;Bounded Waiting (유한대기) : 기다리는 시간이 유한해야 한다. (starvation을 막아야 한다)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Alogridm1&lt;/strong&gt; 1번 동시에 들어가는 경우를 해결&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// init turn
// process P0의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내턴이 아니면 waiting...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// process P1의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내턴이 아니면 waiting...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 경우 &lt;u&gt;critical secion&lt;/u&gt;에는 동시에 진입하는 경우는 해결하지만 한 프로세스가 &lt;u&gt;critical section&lt;/u&gt;에 진입할 필요가 없어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;turn&lt;/code&gt;을 바꿔놓지 않는다면 다른 프로세스는 영원히 못들어 가고 while만 뺑뺑이 돌게된다…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alogridm2&lt;/strong&gt; algo1의 문제를 해결&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// process P0의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// waiting...
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// critical section
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발 내림
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// process P1의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// waiting...
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// critical section
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발 내림
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;u&gt;critical secion&lt;/u&gt;에 진입하기 전에 깃발을 들고 작업 후 깃발을 내린다. 그러면 다른 프로세스는 상대의 깃발이 들려있을 경우 while을 돌며 대기하다가 깃발이 내려갈경우 진입하게 된다. 그러나 &lt;code class=&quot;highlighter-rouge&quot;&gt;flag[0] = true; // 내 깃발을 듬&lt;/code&gt; 에서 인터럽트가 발생해서 다른 프로세스가 실행 될 경우 두 프로세스가 깃발을 동시에 들게 되어 아무도 진입하지 못하는 문제가 발생한다. 결국 동시성은 해결하지만 서로 눈치만 보다 진행이 되지 않는 경우가 생길 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alogridm3&lt;/strong&gt; algo1과 2의 문제 해결 (Peterson의 알고리즘)&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// process P0의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 상대에게 턴을 넘김
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// waiting...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// process P1의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 상대에게 턴을 넘김
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// waiting...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;turn이라는 변수를 두어서 2와 같이 서로 눈치만 보는 경우를 해결하였다.&lt;/p&gt;

&lt;p&gt;깃발을 동시에 들더라도 turn은 0아니면 1의 값을 가지게 되므로 두 프로세스 중 하나만 &lt;u&gt;critical section&lt;/u&gt;에 진입하게 된다.&lt;/p&gt;

&lt;p&gt;여기서 이 두 코드의 순서를 바꾸게 되면 제대로 동작하지 않으니 유의하자.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 상대에게 턴을 넘김
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;간단해 보이지만 생각보다 잘 짜여진 코드인것 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;그러나&lt;/strong&gt; &lt;em&gt;Peterson의 알고리즘&lt;/em&gt;으로 제대로 동작하는 것은 보장하게 되지만 비효율적인 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;왜냐하면 &lt;u&gt;critical section&lt;/u&gt;에 진입한 프로세스가 있을경우 다른 프로세스는 cpu를 획득해봤자 while문만 계속 돌면서 cpu를 낭비하기 때문이다. 이를 &lt;strong&gt;Spin Lock&lt;/strong&gt;이라고 한다. 	&lt;em&gt;*spin lock : 계속 cpu와 메모리를 쓰면서 wait (busy-waiting)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;사실 Critical Section 문제를 해결하기 위해 하드웨어 지원을 받는다면 더 쉽게 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;하드웨어적으로 &lt;strong&gt;Test &amp;amp; Modify&lt;/strong&gt;를 &lt;u&gt;atomic&lt;/u&gt;하게 수행하게 된다면 간단히 해결된다.&lt;/p&gt;

&lt;p&gt;즉, 앞의 알고리즘처럼 flag와 turn을 셋팅하고 while에서 검사하여 진행하는 것이 아니라 읽고 쓰는 작업을 Test_and_Set() 이라는 하드웨어 지원 함수로 한번에 수행하면 된다는 것이다. 이렇게 &lt;u&gt;atomic&lt;/u&gt;하게 수행된다면 어느 순간에 인터럽트 되더라도 일관성을 유지할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test_and_Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 락을 걸면서 바로 critical section에 진입함
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// ciritical section
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;semaphores&quot;&gt;Semaphores&lt;/h2&gt;

&lt;p&gt;세마포어는 앞서 살펴본 방식들을 추상화 시킨것이다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// while(S&amp;lt;=0); S--;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// S++;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;P 연산은 critical section에 진입할때 S를 감소시키고 V 연산은 자원을 다시 내놓는 작업을 한다.&lt;/p&gt;

&lt;p&gt;세마포어는 자원을 여러 프로세스가 점유할 수 있는 Counting semaphore와 Binary semaphore가 있다.&lt;/p&gt;

&lt;p&gt;Binary semaphore는 세마포어가 하나인 경우(0 or 1만 가질 수 있는 세마포어)를 말하며 앞에서 본 Mutual Exclusion의 줄여 &lt;strong&gt;mutex&lt;/strong&gt;라고도 한다.&lt;/p&gt;

&lt;p&gt;세마포어를 사용하여 critical section문제를 해결하는 코드는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// process P1의 코드
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이번에는 세마포어를 사용하여 SpinLock문제를 해결해보자.&lt;/p&gt;

&lt;p&gt;앞의 세마포어 S는 단순히 자원의 갯수를 의미하지만 세마포어 구조체를 확장하여 Process 리스트를 추가하고 critical section에 진입하지 못하는 프로세스들을 줄세우게 한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이러한 방식은 &lt;strong&gt;block&amp;amp;wake up&lt;/strong&gt; 방식이라고 하면 &lt;em&gt;block()&lt;/em&gt;과 &lt;em&gt;wakeup()&lt;/em&gt; 을 지원한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;block()&lt;/em&gt;은 해당 프로세스의 PCB를 세마포어에 대한 List에 추가한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;wakeup()&lt;/em&gt;은 block된 프로세스의 PCB를 레디큐로 옮긴다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* 
S.value--;
if(S.value &amp;lt; 0) {
add to S.L;
block();
}
*/&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
S.value++;
remove P from S.L;
wakeup(P);
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;프로세스의 상태도에 나와있는 공유메모리의 큐에 잠자게 하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/processState.png&quot; alt=&quot;processState&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 &lt;strong&gt;busy-waiting&lt;/strong&gt; 방식보다 &lt;strong&gt;block&amp;amp;wake-up&lt;/strong&gt; 방식이 더 효율적이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;세마포어를 사용할때 DeadLock과 Starvation문제가 발생할 가능성이 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DeadLock&lt;/strong&gt; : 둘 이상의 프로세스가 서로 상대방이 가진 자원을 기다리며 block된 상태.&lt;/p&gt;

&lt;p&gt;예를들어 P0이 S를 획득하고, P1이 Q를 획득한 상황에서 P0이 Q를 기다리고 P1이 S를 기다린다면 영원히 서로 기다리게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;세마포어의 단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;코딩하기 힘들다 -&amp;gt; P연산과 V연산을 쌍으로 정확히 코딩해야한다&lt;/li&gt;
  &lt;li&gt;정확성 입증이 힘들다&lt;/li&gt;
  &lt;li&gt;자발적 협력이 필요하다&lt;/li&gt;
  &lt;li&gt;한번의 실수가 전체 시스템에 치명적이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;나중에 모니터를 사용해서 단점을 개선할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;동기화에-관련된-문제들&quot;&gt;동기화에 관련된 문제들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Bounded Buffer Problem (Producer-Consumer Problem)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;유한한 버퍼를 두고 생산자와 소비자 사이에서 발생할 수 있는 문제이다.&lt;/p&gt;

&lt;p&gt;생산자 프로세스는 버퍼가 비어있어야 데이터를 생성할 수 있기 때문에 버퍼에 빈 공간이 있을때까지 대기한다.&lt;/p&gt;

&lt;p&gt;소비자 프로세스는 버퍼가 차 있어야 데이터를 읽을 수 있기 때문에 버퍼에 데이터가 있을때까지 대기한다.&lt;/p&gt;

&lt;p&gt;당연히 공유메모리에 여러 프로세스가 접근하기 때문에 동기화가 이루어져야하고, busy-waiting 도 해결해야 한다.&lt;/p&gt;

&lt;p&gt;세마포어를 사용하여 해결하기 위해 두개의 카운팅 세마포어와 뮤텍스가 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semaphore full = 0, empty = n, mutex = 1;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Producer
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;produce&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 자원을 생산
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 빈 버퍼를 얻는다 (n--)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 다른 생산자나 소비자의 접근을 막는 lock
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내용이 들어있는 버퍼를 하나 추가
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Consumer
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내용이 들어있는 버퍼를 얻는다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 자원을 소비
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 빈 버퍼를 하나 추가
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 자원을 소비
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Readers Writers Problem&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현실세계에서 DB의 데이터 접근/쓰기 문제와 비슷하다. 한 프로세스가 write중일때 다른 프로세스는 접근할 수 없지만 Read는 동시에 해도 상관없다. 즉, Reader들에 대해서는 동시접근을 허용하며, Writer들에게는 배타적 접근을 지원한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 현재 DB에 접근하는 Reader의 수
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// readcount의 상호배타적 접근을 위한 mutex
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Writer
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;writing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Reader
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// readcount 통제
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Writer의 접근을 막는 lock (만약 1이 아니라 1보다 크다면 이전에 이미 lock이 걸려있음)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Writer의 접근을 허용
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;하지만 Reader가 끊임없이 read를 시도하면 Writer는 Starvation이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;때문에 일정시간을 기준으로만 Reader를 받고 Writer에게 기회를 주는 방식으로 해결할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Dining Philosophers Problem (식사하는 철학자 문제)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다섯명의 철학자가 원탁에 앉아 식사하는 상황에서 발생하는 문제이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/philosophers.png&quot; alt=&quot;philosophers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다섯명의 철학자가 동시에 왼쪽 젓가락을 잡는 경우 DeadLock이 발생한다.&lt;/p&gt;

&lt;p&gt;해결 방법으로는 젓가락을 집기 전에 양쪽이 가능한지 먼저 확인한 뒤 밥을 먹게 하는 방법이 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 양옆이 eating상태가 아닌지 체크하고 내 상태를 eating으로 만든다
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 양옆을 깨워준다
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 각각의 Philosopher 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;think&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;monitor&quot;&gt;Monitor&lt;/h2&gt;

&lt;p&gt;공유 데이터에 대한 안전한 공유를 보장하기 위해 고급언어에서 지원하는 도구&lt;/p&gt;

&lt;p&gt;이전의 세마포어에의 단점을 개선하고자 나온것이 모니터이다.&lt;/p&gt;

&lt;p&gt;모니터는 공유데이터와 함께 접근하기 위한 operations를 제공한다. 즉, 공유데이터를 접근하기 위해 프로그래머가 직접 lock을 걸고 풀고 할 필요없이 제공하는 operation을 사용함으로써 그 책임을 모니터에게 이양시킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/monitor.png&quot; alt=&quot;monitor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모니터에는 condition변수를 두어 세마포어에서 사용한 block&amp;amp;wake-up 방식으로 구현한 큐처럼 관리한다.&lt;/p&gt;

&lt;p&gt;Condition variable은 큐에 줄을 세우는 wait()와 깨우는 signal() 연산을 제공한다.&lt;/p&gt;

&lt;p&gt;동기화에 관한 문제를 모니터를 사용해 해결해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Bounded Buffer Problem (Producer-Consumer Problem)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;monitor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bounded_buffer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 공유데이터가 모니터 안에 정의
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 버퍼에 남은 공간이 없으면
&lt;/span&gt;    		&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 기다린다. 나중에 소비자가 signal()로 빈버퍼가 생김을 알리면 깨어남
&lt;/span&gt;    	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 데이터 추가
&lt;/span&gt;    	&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 버퍼가 가득 차면
&lt;/span&gt;    		&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;세마포어처럼 P연산 V연산을 쓰지 않고 일반적인 상식에 맞게 생산자는 버퍼에 빈공간 있는지 체크하고 없으면 wait()를 한다.&lt;/p&gt;

&lt;p&gt;따라서 프로그래머 입장에서는 자연스럽게 코딩할 수 있기 때문에 실수가 적어지게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Dining Philosophers Problem (식사하는 철학자 문제)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;monitor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dining_philosopher&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 양옆이 eating상태가 아닌지 체크하고 내 상태를 eating으로 만든다
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// test후에 불가능하면 잠재운다
&lt;/span&gt;        	&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    	&lt;span class=&quot;c1&quot;&gt;// 양옆을 깨워준다
&lt;/span&gt;    	&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
    		 &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
    		 &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    		&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    		&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 각각의 Philosopher 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;think&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;deadlock&quot;&gt;DeadLock&lt;/h2&gt;

&lt;p&gt;둘 이상의 프로세스가 서로 상대방이 가진 자원을 기다리며 block된 상태.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DeadLock 발생 4가지 조건&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Mutual exclusion (상호 배제)&lt;/strong&gt; : 매순간 하나의 프로세스만 자원을 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No preemption (비선점)&lt;/strong&gt; : 자원을 강제로 빼앗기지 않음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Hold and wait (보유 대기)&lt;/strong&gt; : 다른 자원을 기다릴때 보유자원을 내놓지 않음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Circular wait (환형 대기)&lt;/strong&gt; : 자원을 기다리는 프로세스간 사이클이 형성되어야 함&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다음과 같은 네가지 조건이 모두 성립할 경우에 DeadLock이 발생한다. 다시말하면 네가지중 하나만 제거를 할 경우 해결 가능하다.&lt;/p&gt;

&lt;p&gt;1번을 제거할 경우 동기화가 제대로 동작하지 않기 때문에 적절하지 않다.&lt;/p&gt;

&lt;p&gt;2번을 제거하려면 선점으로 만들어주는 것인데 이는 프린터가 출력되는 도중 여러 내용이 섞이는 것과 같기 때문에 적절치 않다.&lt;/p&gt;

&lt;p&gt;3번을 만족하지 않는다는 것은 모든 자원이 충족될 경우에만 일을 하기 때문에 starvation이 발생할 수 있고 비효율적이다.&lt;/p&gt;

&lt;p&gt;4번을 제거하는 것이 가장 적절한 방법으로 식사하는 철학자 문제와 같이 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Banker’s algoridm :&lt;/strong&gt; 공유데이터에 복수의 자원이 있을경우 deadlock을 해결하는 방법&lt;/p&gt;

&lt;p&gt;unsafe한 상황이 처하지 않도록 유지한다.&lt;/p&gt;

&lt;p&gt;현재 할당된 자원과 최대요청자원, 가능한 자원, 필요한 자원을 표로 나타내어 가용자원이 추가요청자원을 충족할 수 있을경우만 자원을 주어서 safe한 상태를 유지한다. 각각의 프로세스들의 최대요청 자원을 사전에 알고있어야 한다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">Process Synchronization</summary></entry><entry><title type="html">xcode Use of undeclared type 에러</title><link href="http://localhost:4000/ios/xcode-Use-of-undeclared-type-%EC%97%90%EB%9F%AC/" rel="alternate" type="text/html" title="xcode Use of undeclared type 에러" /><published>2018-08-07T00:00:00+09:00</published><updated>2018-08-07T00:00:00+09:00</updated><id>http://localhost:4000/ios/xcode%20%22Use%20of%20undeclared%20type%22%20%EC%97%90%EB%9F%AC</id><content type="html" xml:base="http://localhost:4000/ios/xcode-Use-of-undeclared-type-%EC%97%90%EB%9F%AC/">&lt;h2 id=&quot;xcode-use-of-undeclared-type-에러-해결법&quot;&gt;Xcode “Use of undeclared type” 에러 해결법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018-08-07-post1/1.png?raw=true&amp;quot;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트 빌드는 되는데 계속해서 오류가 발생하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;실행이 잘 되기 때문에 그냥 냅두고 계속 진행했지만 자동완성이 먹히지 않고 거슬려서 이유를 찾아보았다.&lt;/p&gt;

&lt;p&gt;원인은 Build Phases에 해당 소스가 추가되지 않았기 때문이었다.&lt;/p&gt;

&lt;p&gt;프로젝트 타겟 - Build Phases 에서 +버튼을 눌러 해당 소스를 추가해주면 해결된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018-08-07-post1/2.png?raw=true&amp;quot;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행하는데 문제가 없었기 때문에 원인을 찾기 힘들었다…&lt;/p&gt;

&lt;p&gt;타겟에 추가가 되지 않았던 이유는 다른 프로젝트에 있는 소스파일을 가져오면서 제대로 설정되지 않았던 것 같다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">Use of undeclared type</summary></entry><entry><title type="html">AWS Lamda 사용기</title><link href="http://localhost:4000/aws/lamda%EC%82%AC%EC%9A%A9%EA%B8%B0/" rel="alternate" type="text/html" title="AWS Lamda 사용기" /><published>2018-07-27T00:00:00+09:00</published><updated>2018-07-27T00:00:00+09:00</updated><id>http://localhost:4000/aws/lamda%EC%82%AC%EC%9A%A9%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/aws/lamda%EC%82%AC%EC%9A%A9%EA%B8%B0/">&lt;h2 id=&quot;lamda를-써보자&quot;&gt;Lamda를 써보자&lt;/h2&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">How to use AWS Lamda.</summary></entry><entry><title type="html">Fastlane으로 빌드 자동화 설정하기</title><link href="http://localhost:4000/ios/ios-%EB%B9%8C%EB%93%9C%EC%9E%90%EB%8F%99%ED%99%94-fastlane-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="Fastlane으로 빌드 자동화 설정하기" /><published>2017-09-18T00:00:00+09:00</published><updated>2017-09-18T00:00:00+09:00</updated><id>http://localhost:4000/ios/%5Bios%5D%20%EB%B9%8C%EB%93%9C%EC%9E%90%EB%8F%99%ED%99%94%20fastlane%20%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/ios/ios-%EB%B9%8C%EB%93%9C%EC%9E%90%EB%8F%99%ED%99%94-fastlane-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/">&lt;p&gt;외주 개발을 하게 되면서 서로 다른 애플 개발자 계정으로 enterprise, adhoc빌드, 스토어 업로드를 처리하다보니&lt;/p&gt;

&lt;p&gt;빌드를 내는데 걸리는 시간이 많아졌고, 상당히 귀찮은 작업이 되었다.&lt;/p&gt;

&lt;p&gt;당시 개발하던 mac의 사양도 높지 않아서 빌드속도도 느릴뿐더러 xcode 스토어 업로드에서 마지막에 알수없는 에러가 발생하였는데&lt;/p&gt;

&lt;p&gt;한시간 넘게 계속 재시도하니까 업로드에 성공한적도 있었다.&lt;/p&gt;

&lt;p&gt;fastlane을 사용하면 이러한 문제도 해결할 수 있고, 추가적으로 좋은 기능들도 이용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;fastlane 설치 및 파일설명&lt;/li&gt;
  &lt;li&gt;Appfile&lt;/li&gt;
  &lt;li&gt;.env&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Fastfile&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Action&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Plugin&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;build multiple targets with a single command&lt;/li&gt;
  &lt;li&gt;get version string&lt;/li&gt;
  &lt;li&gt;slack message&lt;/li&gt;
  &lt;li&gt;appicon with badge&lt;/li&gt;
  &lt;li&gt;upload ipa and plist to the server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##fastlane 설치&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;터미널에서 다음 명령어를 입력한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sudo gem install fastlane –verbose`&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;해당 프로젝트로 이동한 후 다음 명령어를 입력한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fastlane init&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;생성된 Appfile, Fastfile, .env파일을 작성한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Appfile에서 애플 개발자 계정을 설정하고 Fastfile로 빌드할 lane을 작성한다.(가장 중요!)&lt;/p&gt;

&lt;p&gt;.env파일은 전역변수를 설정하여 Fastfile에서 편리하게 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;##파일 설정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Appfile&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여러 개발자계정으로 빌드를 할 경우에 Fastfile에서 설정한 lane이름으로 분기하여 id를 설정할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for_lane :first_lane do
     app_identifier &quot;ONE&quot;
     apple_id &quot;ONE&quot;
     team_id &quot;ONE&quot;
end

for_lane :second_lane do
     app_identifier &quot;TWO&quot;
     apple_id &quot;TWO&quot;
     team_id &quot;TWO&quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;.env&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;각각의 프로젝트에서 Fastfile을 다시 작성하는것보다 .env파일을 사용하여 프로젝트이름이나 url등을 변수로 선언하면&lt;/p&gt;

&lt;p&gt;약간의 Fastfile을 수정하는것만으로 다른 프로젝트에서도 용이하게 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  SLACK_URL=&quot;&quot;  # slack hook address
 
  RELEASE_TARGET=&quot;&quot;
  ADHOC_TARGET=&quot;&quot;
  ENTERPRISE_TARGET=&quot;&quot;
 
  # git checkout for removing badge
  BADGE_REMOVE_COMMIT=&quot;../{PROJECT_LOCATION}/Assets.xcassets/AppIcon.appiconset&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;*- *Fastfile**&lt;/p&gt;

&lt;p&gt;Fastfile은 lane시작 전에 수행할 코드를 넣는 &lt;code class=&quot;highlighter-rouge&quot;&gt;before_all do ~ end&lt;/code&gt;과 여러 lane들 그리고, lane작업 후에 호출되는&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;after_all do ~ end&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;error do ~ end&lt;/code&gt;로 구성할 수 있다.&lt;/p&gt;

&lt;p&gt;보통 before_all에 인증서 관련한 명령과 pod install수행 구문들을 넣어주고 after_all이나 error 에 슬랙 메시지, git관련 명령
들을 수행하면 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;action&quot;&gt;Action&lt;/h2&gt;
&lt;p&gt;Action은 Fastlane에서 기본적으로 내장되어있는 기능으로 test, build, screenshot, code signing등이 있다.
https://docs.fastlane.tools/actions/&lt;/p&gt;

&lt;h2 id=&quot;plugin&quot;&gt;Plugin&lt;/h2&gt;
&lt;p&gt;플러그인은 부가적인 option이며 fastlane에서 자체적으로 제공하는것이 아니라 오픈소스 컨트리뷰터들이 만들어서 제공하는 기능이다.&lt;/p&gt;

&lt;p&gt;사용가능한 플러그인 목록
https://docs.fastlane.tools/plugins/available-plugins/&lt;/p&gt;

&lt;p&gt;사용하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;fastlane add_plugin [plugin명]&lt;/code&gt; 으로 따로 설치해야한다.&lt;/p&gt;

&lt;p&gt;fastlane은 루비로 되어있어서 루비를 잘 다룬다면 plugin을 만들어 쓸 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;개인적으로 유용하게 쓰고 있는 plugin으로는 badge 인데 앱 아이콘이 비슷해서 헷갈리지 않도록 앱 아이콘에 뱃지를 달 수 있다
https://github.com/HazAT/fastlane-plugin-badge&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fastlane add_plugin badge
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;빌드실행&quot;&gt;빌드실행&lt;/h2&gt;

&lt;p&gt;설정이 끝나고 터미널에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;fastlane [lane명]&lt;/code&gt; 을 입력하면 빌드가 시작된다.&lt;/p&gt;

&lt;h4 id=&quot;ios-all&quot;&gt;ios all&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fastlane all
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ios-release&quot;&gt;ios release&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fastlane release
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ios-adhoc&quot;&gt;ios adhoc&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fastlane adhoc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ios-enterprise&quot;&gt;ios enterprise&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fastlane enterprise
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;about-fastlane&quot;&gt;About Fastlane&lt;/h2&gt;
&lt;p&gt;For more information about Fastlane -&amp;gt; https://fastlane.tools/&lt;/p&gt;

&lt;p&gt;Fastlane github -&amp;gt; https://github.com/fastlane/fastlane&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><category term="ios" /><summary type="html">지속적인 통합 Fastlane</summary></entry><entry><title type="html">[git] 자주 쓰는 git명령어</title><link href="http://localhost:4000/git/git-%EC%9E%90%EC%A3%BC-%EC%93%B0%EB%8A%94-git%EB%AA%85%EB%A0%B9%EC%96%B4/" rel="alternate" type="text/html" title="[git] 자주 쓰는 git명령어" /><published>2017-09-08T00:00:00+09:00</published><updated>2017-09-08T00:00:00+09:00</updated><id>http://localhost:4000/git/%5Bgit%5D%20%EC%9E%90%EC%A3%BC%20%EC%93%B0%EB%8A%94%20git%EB%AA%85%EB%A0%B9%EC%96%B4</id><content type="html" xml:base="http://localhost:4000/git/git-%EC%9E%90%EC%A3%BC-%EC%93%B0%EB%8A%94-git%EB%AA%85%EB%A0%B9%EC%96%B4/">&lt;aside class=&quot;sidebar__right&quot;&gt;
&lt;nav class=&quot;toc&quot;&gt;
    &lt;header&gt;&lt;h4 class=&quot;nav__title&quot;&gt;&lt;i class=&quot;fa fa-file-text&quot;&gt;&lt;/i&gt; On This Page&lt;/h4&gt;&lt;/header&gt;
&lt;ul class=&quot;toc__menu&quot; id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#커밋-되돌리기&quot; id=&quot;markdown-toc-커밋-되돌리기&quot;&gt;커밋 되돌리기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#원격-레포-커밋-되돌리기&quot; id=&quot;markdown-toc-원격-레포-커밋-되돌리기&quot;&gt;원격 레포 커밋 되돌리기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#commit했었던-곳으로-돌아가기&quot; id=&quot;markdown-toc-commit했었던-곳으로-돌아가기&quot;&gt;commit했었던 곳으로 돌아가기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#원격-파일-삭제하기&quot; id=&quot;markdown-toc-원격-파일-삭제하기&quot;&gt;원격 파일 삭제하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;/nav&gt;
&lt;/aside&gt;

&lt;h2 id=&quot;커밋-되돌리기&quot;&gt;커밋 되돌리기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git reset HEAD^&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 명령을 사용하면 커밋 하나를 되돌릴 수 있다. 두개를 되돌리려면&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$git reset HEAD~2&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;원격-레포-커밋-되돌리기&quot;&gt;원격 레포 커밋 되돌리기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git push origin +ios&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이렇게 +를 붙여주면 경고는 무시하고 데이터가 손실되도 push한다.&lt;/p&gt;

&lt;h2 id=&quot;commit했었던-곳으로-돌아가기&quot;&gt;commit했었던 곳으로 돌아가기&lt;/h2&gt;
&lt;p&gt;먼저&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git reflog&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;로 해당 HEAD번호를 확인한다.
￼&lt;/p&gt;

&lt;p&gt;ex) 배너 예외처리로 돌아가기&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-09-08-post1/1.png?raw=true&amp;quot;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git reset —hard HEAD@{21}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;원격-파일-삭제하기&quot;&gt;원격 파일 삭제하기&lt;/h2&gt;

&lt;p&gt;.gitignore를 올리기전에 xcuserstate 를 원격지로 푸시했다.
이후에 필요없는 breakPoint같은 파일이 자꾸 깃 스테이지에 올라간다.&lt;/p&gt;

&lt;p&gt;원격 저장소에 있는 파일을 지우려면 git 명령어를 통해 삭제 후 푸시를 해줘야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git rm —cached [flileName]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;git rm 은 로컬과 원격을 모두 삭제하므로 —cached를 꼭 붙여줘야 한다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><category term="git" /><summary type="html">On This Page</summary></entry><entry><title type="html">status bar</title><link href="http://localhost:4000/ios/ios-status-bar-%EB%8B%A4%EB%A3%A8%EA%B8%B0/" rel="alternate" type="text/html" title="status bar" /><published>2017-08-19T00:00:00+09:00</published><updated>2017-08-19T00:00:00+09:00</updated><id>http://localhost:4000/ios/%5Bios%5D%20status%20bar%20%EB%8B%A4%EB%A3%A8%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/ios/ios-status-bar-%EB%8B%A4%EB%A3%A8%EA%B8%B0/">&lt;h2 id=&quot;status-bar&quot;&gt;status bar&lt;/h2&gt;

&lt;p&gt;ios에서 상태바를 커스터마이징 가능한 부분은 상태바의 백그라운드 색상변경(아무색이나 가능)과 상태바 안의 텍스트 색상변경(하얀색 or 검정색으로 제한)
이다.&lt;/p&gt;

&lt;p&gt;글자색도 변경해보고 싶어지만 애플가이드라인에서는 밝은 배경일때 검은색 텍스트 / 어두운 배경일때 하얀 텍스트를 쓰라고 권장하고 있는 부분이다.
(알록달록한 색상은 불가능함)&lt;/p&gt;

&lt;h3 id=&quot;상태바-백그라운드-색상-변경하기&quot;&gt;상태바 백그라운드 색상 변경하기&lt;/h3&gt;

&lt;p&gt;상태바 백그라운드 색상은 뷰를 만들어서 addSubView 하는 방법과 “statusBar” key로 상태바를 get해서 바꾸는 방법이 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let statusBar = UIView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 20))
        statusBar.backgroundColor = .green // 원하는 색상 지정
        window?.rootViewController?.view.addSubview(statusBar)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension UIApplication {
    var statusBarView: UIView? {
        return value(forKey: &quot;statusBar&quot;) as? UIView
    }
}

// insert code in AppDelegate
UIApplication.shared.statusBarView?.backgroundColor = .black

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;상태바 백그라운드 색상변경은 비교적 간단하니 이정도로 넘어가고 텍스트 변경을 해보자.&lt;/p&gt;

&lt;p&gt;텍스트 변경은 잘못 접근하면 잘 먹히지가 않아서 정리를 제대로 해둬야겠다고 생각했다.&lt;/p&gt;

&lt;h3 id=&quot;상태바-텍스트-변경하기&quot;&gt;상태바 텍스트 변경하기&lt;/h3&gt;

&lt;p&gt;상태바를 원하는대로 바꾸기 위해서는 info.plist의 속성설정에 따라 두가지 종류로 나눌 수 있다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/plist.png?raw=true&amp;quot;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;바로 이 속성을 NO로 지정하느냐 YES로 지정하느냐에 따라 설정하는 방법이 다르다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;case1. View controller-based status bar appearance = NO&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AppDelegate - didFinishLaunchingWithOptions메서드 안에 다음 소스를 추가한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplication.shared.statusBarStyle = .lightContent // white color&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplication.shared.statusBarStyle = .default // black color&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이렇게 설정을 해두면 모든 뷰컨트롤러에서 같게 세팅이 된다.&lt;/p&gt;

&lt;p&gt;info.plist에서 속성을 NO로 지정하지 않았다면 아무리 설정해봐도 먹히지 않으니
바뀌지 않는다면 plist를 다시 확인해보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;case2. View controller-based status bar appearance = YES&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 방식은 모든 뷰컨트롤러마다 스타일을 지정해 주어야 한다.&lt;/p&gt;

&lt;p&gt;스타일을 지정하는 방법은 이전과 다르게 UIViewController의&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var preferredStatusBarStyle: UIStatusBarStyle

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;속성을 오버라이드 해서 바꾸는 방법으로 접근해야한다.&lt;/p&gt;

&lt;p&gt;모든 ViewController가 상속받는 base ViewController가 있다면 여기에 설정해 놓는 것이 수월하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var statusBarStyle: UIStatusBarStyle = .lightContent { didSet { setNeedsStatusBarAppearanceUpdate() } }
    
    override var preferredStatusBarStyle: UIStatusBarStyle {
        return statusBarStyle
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Navigation 뷰컨을 쓴다면 확장해서 설정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension UINavigationController {
    
    override open var preferredStatusBarStyle: UIStatusBarStyle {
        return .lightContent
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">How to use status bar.</summary></entry></feed>