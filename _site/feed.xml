<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-09-09T18:49:11+09:00</updated><id>http://localhost:4000/</id><title type="html">Jingyu playground</title><subtitle></subtitle><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><entry><title type="html">OSI 7계층</title><link href="http://localhost:4000/network/network-osi7%EA%B3%84%EC%B8%B5/" rel="alternate" type="text/html" title="OSI 7계층" /><published>2018-09-09T00:00:00+09:00</published><updated>2018-09-09T00:00:00+09:00</updated><id>http://localhost:4000/network/%5Bnetwork%5D%20osi7%EA%B3%84%EC%B8%B5</id><content type="html" xml:base="http://localhost:4000/network/network-osi7%EA%B3%84%EC%B8%B5/">&lt;p&gt;OSI7계층의 중요한 목적은 표준과 학습도구이다. 표준화는 다양한 장비 사이에서 같은 규칙을 사용하여 이질성을 감소시킨다.&lt;/p&gt;

&lt;p&gt;뿐만 아니라 각각의 층에 대한 프로토콜이 잘 정립되어 있어 해당하는 분야에만 집중 할 수 있다. 예를들어 라우터를 제작할 경우 3계층에 대한 프로토콜만 맞춰어 제작하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Physical - DataLink - Network - Transport - Session - Presentation - Application&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각 계층의 쓰임과 쓰이는 프로토콜에 대해 정리해보았다.&lt;/p&gt;

&lt;h2 id=&quot;application&quot;&gt;Application&lt;/h2&gt;

&lt;p&gt;사용자 프로그램. 웹이나 FTP같은 유저 인터페이스.&lt;/p&gt;

&lt;p&gt;프로토콜: HTTP, DNS, FTP&lt;/p&gt;

&lt;h2 id=&quot;presentation&quot;&gt;Presentation&lt;/h2&gt;

&lt;p&gt;데이터의 표현. 암호화/복호화. 운영체제의 한 부분으로 JPEG같은 확장자처럼 전송데이터를 이해할수 있게 번역하는 역할을 수행&lt;/p&gt;

&lt;p&gt;프로토콜: JPEG, PNG&lt;/p&gt;

&lt;h2 id=&quot;session&quot;&gt;Session&lt;/h2&gt;

&lt;p&gt;2개의 기기 사이에 세션이 이루어짐. 포트(Port)연결.&lt;/p&gt;

&lt;p&gt;프로토콜 :SSH, TLS&lt;/p&gt;

&lt;h2 id=&quot;transport&quot;&gt;Transport&lt;/h2&gt;

&lt;p&gt;데이터 용량 및 속도 등을 처리. 발신지대 목적지(종단 대 종단)간 제어와 에러를 관리. 패킷들의 전송이 유효한지 확인. 신뢰성 통신을 보장하기도 함&lt;/p&gt;

&lt;p&gt;프로토콜 : TCP, UDP&lt;/p&gt;

&lt;h2 id=&quot;network&quot;&gt;Network&lt;/h2&gt;

&lt;p&gt;패킷을 발신지부터 목적지까지 전달.&lt;/p&gt;

&lt;p&gt;프로토콜 : IP, ARP&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*IP :패킷의 분할/병합기능을 한다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*ARP : 패킷에 있는 ip주소를 물리적인 MAC주소로 변환시켜주는 프로토콜이다. DataLink계층으로 전달될때 MAC주소를 프레임으로 캡슐화해서  보낸다.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;datalink&quot;&gt;DataLink&lt;/h2&gt;

&lt;p&gt;두개의 직접 연결된 노드 간 frame 전송. 오류 수정 및 flow control.&lt;/p&gt;

&lt;p&gt;프로토콜: MAC, PPP&lt;/p&gt;

&lt;h2 id=&quot;phsical&quot;&gt;Phsical&lt;/h2&gt;

&lt;p&gt;두 노드를 물리적으로 연결시켜주는 방식을 다룸.&lt;/p&gt;

&lt;p&gt;프로토콜 : ethernet&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><category term="network" /><summary type="html">OSI7계층의 중요한 목적은 표준과 학습도구이다. 표준화는 다양한 장비 사이에서 같은 규칙을 사용하여 이질성을 감소시킨다.</summary></entry><entry><title type="html">HTTP와 HTTPS 프로토콜과 인증서</title><link href="http://localhost:4000/network/network-HTTP%EC%99%80-HTTPS/" rel="alternate" type="text/html" title="HTTP와 HTTPS 프로토콜과 인증서" /><published>2018-09-09T00:00:00+09:00</published><updated>2018-09-09T00:00:00+09:00</updated><id>http://localhost:4000/network/%5Bnetwork%5D%20HTTP%EC%99%80%20HTTPS</id><content type="html" xml:base="http://localhost:4000/network/network-HTTP%EC%99%80-HTTPS/">&lt;p&gt;​&lt;/p&gt;

&lt;h1 id=&quot;protocol&quot;&gt;Protocol&lt;/h1&gt;

&lt;p&gt;프로토콜(Protocol)은 컴퓨터나 네트워크 장비가 서로 통신하기 위해 미리 정해 놓은 약속을 뜻한다.&lt;/p&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP&lt;/h2&gt;

&lt;p&gt;HyperText Transfer Protocol의 약자로 WWW(World Wide Web)에서 hypertext 문서를 교환하기 위하여 사용되는 통신규약이다.&lt;/p&gt;

&lt;p&gt;대표적인 규칙으로는 Status code와 Request Method가 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Status code:&lt;/strong&gt;  http 통신중 요청의 상태 정보를 제공한다. 공식 적인 상태코드 목록은 &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;IANA&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;상태코드의 첫 숫자는 응답의 종류를 나타낸다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1xx - Informational - 정보교환&lt;/li&gt;
  &lt;li&gt;2xx - Success - 성공
200 - OK	- 요청이 성공적으로 전송됨&lt;/li&gt;
  &lt;li&gt;3xx - Redirection - 방향 지정
301 - Moved Permanently - 요청 페이지의 영구적인 위치 변화
302 - Found	- 요청 페이지이 일시적인 위치 변화&lt;/li&gt;
  &lt;li&gt;4xx - Client Error - 클라이언트 오류
404 - Not Found - 요청받은 자원을 서버에서 찾을 수 없을때 나타나는 상태 
405 - Method Not Allowed - 서버에서 사용자가 요청한 주소의 메소드를 지원하지 않을때 나타남&lt;/li&gt;
  &lt;li&gt;5xx - server Error - 서버 오류&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Request methods:&lt;/strong&gt; 요청이 수행될 작업의 방법을 나타낸다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;OPTIONS: 요청한 URL에 어떠한 메소드 요청이 가능한지 묻는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET: 다른 작업없이 데이터의 검색에 이용.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HEAD: 데이터의 검색에 이용하나 GET과는 다르게 응답 HEADER만 받는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;POST: URL에 새로운 데이터를 보낼때 사용.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PUT: URL에 저장될 정보를 보낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DELETE: URL의 리소스를 삭제한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TRACE: 보낸 메세지를 다시 돌려받는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CONNECT: 프록시에서 사용되는 예약 메소드.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP의 한계&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;암호화 안된 방식으로 데이터를 주고 받음 : 데이터를 중간에 가로챌 수 있음.&lt;/li&gt;
  &lt;li&gt;통신하는 상대방의 신원을 확인하지 않음 : 상대방이 누군지 확인하지 않고 요청/응답을 보냄. 중간에 상대방인척하고 데이터를 가로챌 수 있음.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h2 id=&quot;https&quot;&gt;HTTPS&lt;/h2&gt;

&lt;p&gt;HTTP를 SSL(Secure Socket Layer)로 한층 더 감싸서 보안을 강화한 것.  =&amp;gt; HTTPS는 SSL프로토콜 위에서  돌아가는 프로토콜이다.&lt;/p&gt;

&lt;p&gt;기존 &lt;strong&gt;HTTP의 한계&lt;/strong&gt;를 극복한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;데이터를 암호화하고&lt;/li&gt;
  &lt;li&gt;통신하는 상대방의 신원을 확인함.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SSL인증은 신뢰할 수 있는 제 3자(CA)의 인증서를 기반으로 돌아간다.&lt;/p&gt;

&lt;p&gt;SSL은 &lt;strong&gt;보안&lt;/strong&gt;과 &lt;strong&gt;성능&lt;/strong&gt;을 고려하여 &lt;strong&gt;대칭키&lt;/strong&gt;와 &lt;strong&gt;공개키&lt;/strong&gt; 라는 두 가지 인증 방식을 가지고 있다.&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&quot;대칭키&quot;&gt;&lt;strong&gt;대칭키&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/network/symmetricKey.png&quot; alt=&quot;symmetricKey&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대칭키(symmetric key) 방식은 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법을 의미한다. 즉, A를 k라는 key로 암호화하여 B로 만들었을때, B를 k로 복호화 할 수 있다는 뜻이다.&lt;/p&gt;

&lt;p&gt;대칭키 방식은 단점이 있다. 암호를 주고 받는 사람들 사이에 대칭키를 전달하는 것이 어렵다는 점이다. 대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화 할 수 있기 때문에 암호가 무용지물이 되기 때문이다. 이런 배경에서 나온 암호화 방식이 공개키방식이다.&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&quot;공개키&quot;&gt;&lt;strong&gt;공개키&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/network/publicKey.png&quot; alt=&quot;publicKey&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공개키(public key) 방식은 한 키로 암호화하면 다른 쌍의 키로 복호화 할 수 있는 private키와 public키의 쌍으로 구성되는 방식이다.&lt;/p&gt;

&lt;p&gt;private키는 절대로 공개해서는 안되는 키로 자신만 가지고 있고, public키는 타인에게 공개한다. public키가 공개되어도 암호화된 내용은 private키로만 복호화 가능하기 때문에 안전하다. 사실 공개키 방식에서는 데이터를 보호하는 목적보다 데이터의 신원을 보장하는 목적이 더 크다. public키로 암호화된 데이터는 보호되어 private키를 가진 유일한 대상만 복호화 할 수 있지만, private키로 암호화된 데이터는 누구나 열어볼 수 있기 때문이다. 웹 사이트에서 비밀번호 찾기를 하면 임시 비밀번호를 주고 비밀번호를 변경하라는 문구가 뜨는 것은 단방향 암호화로 원래 비밀번호를 찾지 못하는 이유일 수 도 있겠지만 타인이 읽을 수도 있기 때문일 것이다. 하지만 암호화된 데이터를 변조하는 것은 private키가 유출되지 않는 이상 불가능하기 때문에 데이터의 신원은 확실히 보장받을 수 있다. 데이터를 제공한 사람의 신원을 보장해주는 것을 &lt;strong&gt;전자서명&lt;/strong&gt;이라고 부른다.&lt;/p&gt;

&lt;p&gt;공개키 방식은 2048bit를 사용하여 128bit를 사용하는 대칭키 방식보다 performance차이가 크게 발생한다. 때문에 &lt;strong&gt;SSL에서는 공개키 방식과 대칭키 방식을 조합하여 사용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트와 서버는 처음 handshake과정에서 클라이언트의 브라우저에 있는 CA리스트와 서버 인증서의 CA가 매칭되는지 검사하고, 랜덤데이터를 사용하여 session키를 생성한다. 이 과정은 공개키 방식으로 암호화되어 진행되고 그 이후는 session키를 대칭키로 사용하여 실제 데이터를 주고 받게 된다.&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://sejoong.github.io/dev/2015/02/15/dev/&quot;&gt;http://sejoong.github.io/dev/2015/02/15/dev/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://opentutorials.org/course/228/4894&quot;&gt;https://opentutorials.org/course/228/4894&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bsidesoft.com/?p=3340&quot;&gt;https://www.bsidesoft.com/?p=3340&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hanjungv.github.io/2017-11-07-1_CS_SSL/&quot;&gt;https://hanjungv.github.io/2017-11-07-1_CS_SSL/&lt;/a&gt;&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><category term="network" /><summary type="html">​</summary></entry><entry><title type="html">TCP와 UDP</title><link href="http://localhost:4000/network/network-TCP%EC%99%80-UDP/" rel="alternate" type="text/html" title="TCP와 UDP" /><published>2018-09-06T00:00:00+09:00</published><updated>2018-09-06T00:00:00+09:00</updated><id>http://localhost:4000/network/%5Bnetwork%5D%20TCP%EC%99%80%20UDP</id><content type="html" xml:base="http://localhost:4000/network/network-TCP%EC%99%80-UDP/">&lt;p&gt;TCP와 UDP는 커널 내부에 구현되어 사용자가 직접 이용하지 못한다. 대신 소켓 인터페이스라는 Transport 계층의 인터페이스를 사용하여 시스템콜 기능으로 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;는 비연결형 프로토콜이다. TCP의 handshaking 과정이 없으며 일방적으로 데이터를 전달하는 통신 프로토콜이다. TCP와 비교하면 안정성은 떨어지지만 속도가 빠르다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;는 연결형 서비스를 지원하는 전송계층 프로토콜이다. 전이중 방식의 양방향 통신을 지원하여 두 프로세스가 동시에 데이터를 전송할 수 있다. 연결형 서비스를 지원하기 위해 연결 설정, 데이터 전송, 연결 헤제 3단계를 순차적으로 진행한다.&lt;/p&gt;

&lt;h3 id=&quot;3-way-handshaking&quot;&gt;3 way handshaking&lt;/h3&gt;

&lt;p&gt;연결을 설정할때 이루어진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스 A, B가 있다고 가정하면, A는 임의의 번호로 SYN 플래그 비트를 전송하여 연결 설정을 요청한다. (Seq=1000, SYN)&lt;/li&gt;
  &lt;li&gt;프로세스 B는 A가 보낸 seq번호에 1을 더하여 ACK를 보내고 임의의 seq번호를 보낸다.(Seq=2000 SYN, ACK=1001)&lt;/li&gt;
  &lt;li&gt;A는 B가 보낸 seq번호에 1을 더하여 ACK를 보내면 연결이 성립된다. (ACK=2001)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/network/3-way-handshake.png&quot; alt=&quot;그림1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;*SYN : Synchronize sequence number&lt;/p&gt;

&lt;p&gt;*ACK : Acknowledgement&lt;/p&gt;

&lt;p&gt;연결이 설정된 이후로는 established 상태로 된다.&lt;/p&gt;

&lt;h3 id=&quot;4-way-handshaking&quot;&gt;4 way handshaking&lt;/h3&gt;

&lt;p&gt;연결을 종료할때 이루어진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A가 할일이 끝나면 FIN을 보내고 A는 FIN_WAIT_1상태로 바뀐다.&lt;/li&gt;
  &lt;li&gt;B는 A가 끝났다는것에 대한 응답 ACK를 보내고 B의 해당 포트를 CLOSE_WAIT로 바꾼다.&lt;/li&gt;
  &lt;li&gt;B가 마무리가 되면 끝났다는 FIN을 A에게 보낸다.&lt;/li&gt;
  &lt;li&gt;A는 B가 끝나다는 것에 대한 응답 ACK를 보낸다. B는 소켓을  CLOSE한다.&lt;/li&gt;
  &lt;li&gt;A는 아직 B로부터 데이터가 받을지 모르기 때문에 일정 시간의 잉여시간을 남겨두는 과정을 거친다. (TIME_WAIT)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/network/4way_handshake.png&quot; alt=&quot;4way_handshake&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연결이 종료될때에는 예기치 못한 상황이 발생하여 FIN_WAIT상태나 CLOSE_WAIT상태로 남아있을 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CLOSE_WAIT&lt;/strong&gt; 상태 : 어플리케이션에서 close()를 적절하게 처리해주지 못하면, TCP 포트는 CLOSE_WAIT 상태로 계속 기다리게 된다. 이렇게 CLOSE_WAIT 상태가 statement에 많아지게 되면, Hang 이 걸려 더이상 연결을 하지 못하는 경우가 생기기도 한다. 따라서 어플리케이션 개발시 여러 상황에 따라 close() 처리를 잘 해줘야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FIN_WAIT_1&lt;/strong&gt; 상태 : FIN_WAIT_1 상태라는 것은 상대방측에 커넥션 종료 요청을 했는데, ACK를 받지 못한 상태로 기다리고 있는 것이다. 이것은 아마 서버를 찾을 수 없는 것으로, 네트워크 및 방화벽의 문제일 수 있다.&lt;/p&gt;

    &lt;p&gt;(FIN_WAIT_1 의 상태는 일정 시간이 지나 Time Out이 되면 자동으로 닫는다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FIN_WAIT_2&lt;/strong&gt; 상태 : FIN_WAIT_2 상태는 클라이언트가 서버에 종료를 요청한 후 서버에서 요청을 접수했다고 ACK를 받았지만, 서버에서 종료를 완료했다는 FIN 을 받지 못하고 기다리고 있는 상태이다. 이상태는 양방의 두번의 통신이 이루어졌기 때문에 네트워크의 문제는 아닌 것으로 판단되며,(FIN 을 보내는 순간에 순단이 있어 못받은 것일 수도 있다.) 서버측에서 CLOSE를 처리하지 못하는 경우일 수도 있다. FIN_WAIT_2 역시 일정시간 후 Time Out이 되면 스스로 Closed 하게 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;어떠한 이유에서 FIN_WAIT_1과 FIN_WAIT_2 상태인 연결이 많이 남아있다면, 문제가 발생할 수 있다. 물론 일정 시간이 지나 Time Out이 되면 연결이 자동으로 종료되긴 하지만, 이 Time Out이 길어서 많은 수의 소켓이 늘어만 난다면, 메모리 부족으로 더 이상 소켓을 오픈하지 못하는 경우가 발생한다.&lt;/p&gt;

&lt;p&gt;(이 경우는 네트워크나 방화벽 또는 어플리케이션에서 close() 처리 등에 대한 문제등으로 발생할 수 있으며, 원인을 찾기가 쉽지 않다.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;이러한 문제 해결을 위해서 FIN_WAIT_1과 FIN_WAIT_2 의 Time Out 시간을 적절히 조절할 필요가 있다.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;tcp의-혼잡제어&quot;&gt;TCP의 혼잡제어&lt;/h2&gt;

&lt;p&gt;흐름제어와 혼잡제어로 인해 호스트간 신뢰성 있는 데이터 전달이 가능하다. 흐름제어는 송신자가 수신자의 버퍼에 맞게 전송속도를 조절하는 것이고, 혼잡제어는 송신자가 네트워크의 상황에 맞춰 흐름을 조절하는 것이다. 빠른 LAN에서 느린 WAN으로 전송하거나 다수의 전송이 하나의 라우터에 몰릴 경우 혼잡이 발생하는데 이러한 문제를 해결하기 위해 TCP에서 혼잡제어 메커니즘을 제공한다. (윈도우 사이즈를 조절하여 혼잡을 제어함)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;slow-start&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;처음 연결이 될때 수신자의 버퍼에 맞춰 보내게 되면 중간 라우터의 버퍼에 부하가 올 수 있다. 때문에 새로운 패킷을 망에 전송하는 비율과 수신자의 ACK를 관찰하여 윈도우 사이즈를 지수함수적으로 증가시키는 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;congestion-avoidance(혼잡회피)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;slow-start&lt;/em&gt;로 지수함수적으로 윈도우 사이즈를 늘리다가 &lt;em&gt;threshold에&lt;/em&gt; 도달하면 선형적으로 늘리는 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;fast-retransmission (빠른 재전송)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;윈도우 사이즈만큼 패킷을 보내고 받게 되는데 수신자측에서는 마지막으로 받은 패킷의 다음번 순번을 ACK의 Sequance에 담아서 보내게 된다. 만약 중간에 순번이 틀리게 된다면 같은 ACK가 계속 발생하게 되고 송신자 측에서 문제를 감지하고 해당 패킷을 재전송하게 된다. 이러한 문제는 혼잡상황에서 발생하기 때문에 window size를 감소시킨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;fast-recovery (빠른 회복)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;혼잡상태가 발생했을때 window size를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/network/congestionControl.png&quot; alt=&quot;congestionControl&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중복 ACK가 발생하면 &lt;em&gt;fast-retransmission&lt;/em&gt;을 수행하고 timeout이 발생하면 &lt;em&gt;slow-start&lt;/em&gt;를 수행한다.&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://www.hackmageddon.com/2011/04/17/tcp-split-handshake-attack-explained/&quot;&gt;https://www.hackmageddon.com/2011/04/17/tcp-split-handshake-attack-explained/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://hyeonstorage.tistory.com/287&quot;&gt;http://hyeonstorage.tistory.com/287&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://needjarvis.tistory.com/157&quot;&gt;http://needjarvis.tistory.com/157&lt;/a&gt;&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><category term="network" /><summary type="html">TCP와 UDP는 커널 내부에 구현되어 사용자가 직접 이용하지 못한다. 대신 소켓 인터페이스라는 Transport 계층의 인터페이스를 사용하여 시스템콜 기능으로 호출된다.</summary></entry><entry><title type="html">DataLink 계층의 기능</title><link href="http://localhost:4000/network/network-DataLink/" rel="alternate" type="text/html" title="DataLink 계층의 기능" /><published>2018-09-06T00:00:00+09:00</published><updated>2018-09-06T00:00:00+09:00</updated><id>http://localhost:4000/network/%5Bnetwork%5D%20DataLink</id><content type="html" xml:base="http://localhost:4000/network/network-DataLink/">&lt;h1 id=&quot;datalink&quot;&gt;DataLink&lt;/h1&gt;

&lt;p&gt;내 컴퓨터에서 다른 컴퓨터로 요청을 할때 링크로 연결되 무수한 라우터(컴퓨터)를 거쳐 목적지에 도착한다. 컴퓨터와 컴퓨터 사이, 즉 physical - physical 사이 통신은 DataLink를 거치게 된다.&lt;/p&gt;

&lt;h2 id=&quot;datalink의-중요-역할&quot;&gt;DataLink의 중요 역할&lt;/h2&gt;

&lt;h3 id=&quot;frame-sysnchronization-동기화&quot;&gt;Frame sysnchronization (동기화)&lt;/h3&gt;

&lt;p&gt;frame의 동기를 맞춘다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*frame : 컴퓨터와 컴퓨터 사이 주고 받는 데이터의 단위&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Flow control&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;수신측와 송신측의 처리속도가 다르기 때문에 전송량이 처리량보다 크다면 데이터가 유실될 수 있다. 이러한 경우를 방지하기 위해서 송신측의 패킷 전송량을 제어하는 기법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error control&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;통신과정에서 발생하는 error를 처리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Physical addressing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 장비 사이의 고유성을 다룬다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Access control&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;누가 데이터를 보내게 할지 정한다.&lt;/p&gt;

&lt;p&gt;즉 데이터 링크계층에서는 &lt;strong&gt;누가 데이터를 보낼것인지, 얼마나 보낼것인지, 어떻게 에러를 다룰지를&lt;/strong&gt; 다룬다.&lt;/p&gt;

&lt;h2 id=&quot;flow-control&quot;&gt;Flow control&lt;/h2&gt;

&lt;p&gt;흐름 제어를 하는 기법은 세가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;XON / XOFF&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시리얼 터미널 사이에서 데이터를 더 이상 받지 못할 경우 on/off 하여 제어한다. 예를 들어 프린터와 컴퓨터 사이에서 프린터큐가  넘치면 off하고 프린터큐에 여유분이 생기면 on하여 데이터를 받는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Stop-and-wait&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;frame을 하나씩 보낸다.&lt;/p&gt;

&lt;p&gt;데이터를 보낸 후 ACK가 올때까지 기다린다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sliding window&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;연속해서 보낼 수 있는 양(window size)을 정해서 frame을 계속해서 보낸다.&lt;/p&gt;

&lt;p&gt;window size는 ACK를 받지 않아도 보낼 수 있는 프레임의 갯수를 의미한다. &lt;em&gt;Stop-and-wait&lt;/em&gt;는 window size가 1인 슬라이딩 위도우 기법이라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;전송측에서는 프레임을 전송할때마다 왼쪽 경계를 오른쪽으로 이동시키고, 전송한 프레임에 대한 ACK를 받을때마다 윈도우의 오른쪽 경계를 오른쪽으로 이동시킨다.&lt;/p&gt;

&lt;p&gt;수신측에서는 수신받을때마다 왼쪽 경계를 오른쪽으로 이동시키고, ACK를 전송할때마다 오른쪽 경계를 오른쪽으로 이동시킨다.&lt;/p&gt;

&lt;h2 id=&quot;error-control&quot;&gt;Error Control&lt;/h2&gt;

&lt;p&gt;오류 제어기법은 오류 검출과 재전송 기능을 한다.&lt;/p&gt;

&lt;p&gt;ARQ(Automatic Repeat Request) : 프레임이 손상될 경우 재전송을 통해 오류를 복수한다.&lt;/p&gt;

&lt;p&gt;이전에 살펴본 &lt;strong&gt;Flow control&lt;/strong&gt; 에서 &lt;em&gt;stop-and-wait&lt;/em&gt;는 정지-대기 ARQ를 사용하여 전송한 프레임의 복사본을 유지하여 NAK를 받거나 ACK가 유실되면 timeout 발생으로 재전송한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sliding-window&lt;/em&gt;는 &lt;em&gt;Go-back-n ARQ&lt;/em&gt;나 &lt;em&gt;Selective-reject ARQ&lt;/em&gt;를 사용하여 구현한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Go-back-n ARQ&lt;/em&gt;는 손실된 프레임이 발견될 경우 마지막에 ACK를 제대로 받은 프레임 이후로 다시 모든 프레임을 재전송하는 기법이다. 제대로 받은 프레임도 다시 재전송하기 때문에 구현은 단순하지만 비효율적인 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Selective-reject ARQ&lt;/em&gt;는 이러한 단점을 극복하였지만 별도의 버퍼와 재정렬이 필요하여 구현이 복잡하다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><category term="network" /><summary type="html">DataLink</summary></entry><entry><title type="html">[git] 파일을 고쳐도 git status가 그대로일때</title><link href="http://localhost:4000/git/git-%ED%8C%8C%EC%9D%BC%EC%9D%84-%EA%B3%A0%EC%B3%90%EB%8F%84-git-status%EA%B0%80-%EA%B7%B8%EB%8C%80%EB%A1%9C%EC%9D%BC%EB%95%8C/" rel="alternate" type="text/html" title="[git] 파일을 고쳐도 git status가 그대로일때" /><published>2018-09-03T00:00:00+09:00</published><updated>2018-09-03T00:00:00+09:00</updated><id>http://localhost:4000/git/%5Bgit%5D%20%ED%8C%8C%EC%9D%BC%EC%9D%84%20%EA%B3%A0%EC%B3%90%EB%8F%84%20git%20status%EA%B0%80%20%EA%B7%B8%EB%8C%80%EB%A1%9C%EC%9D%BC%EB%95%8C</id><content type="html" xml:base="http://localhost:4000/git/git-%ED%8C%8C%EC%9D%BC%EC%9D%84-%EA%B3%A0%EC%B3%90%EB%8F%84-git-status%EA%B0%80-%EA%B7%B8%EB%8C%80%EB%A1%9C%EC%9D%BC%EB%95%8C/">&lt;h1 id=&quot;파일을-생성하거나-수정했는데-git-상태변화가-없을때&quot;&gt;파일을 생성하거나 수정했는데 git 상태변화가 없을때&lt;/h1&gt;

&lt;p&gt;파일을 생성하고 작업을 했는데 git status에 아무 변화가 없거나 commit할게 없거나 add할게 없다고 나오는 상황이 발생하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;이 상황에서 살펴볼 것은 먼저 &lt;strong&gt;.gitignore&lt;/strong&gt;에 해당 파일이 등록되어 있는지 확인해 보아야 할 것이다.&lt;/p&gt;

&lt;p&gt;커맨드창에 다음과 같이 입력해서 해당 파일을 찾아본다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gitignore&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;만약 이 방법에 해당하지 않는다면 다음 명령어를 입력해본다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ignored&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/git/gitstatusIgnore.png&quot; alt=&quot;gitstatusIgnore&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진처럼 ignore된 파일들의 리스트가 나온다.&lt;/p&gt;

&lt;p&gt;여기서 해당 파일이 존재한다면 다음 명령어로 강제로 추가해 줄 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;—본문 추가&lt;/p&gt;

&lt;p&gt;계속해서 새로 생성한 file이 ignored 되는 현상이 발생했다.&lt;/p&gt;

&lt;p&gt;분명 .gitignore에는 없는데 왜 자꾸 강제로 ignore되는 것일까?&lt;/p&gt;

&lt;p&gt;알아보니 git에서 global한 ignore 설정을 적용시킬 수 있는 .gitignore_global 이라는 파일이 있었다.&lt;/p&gt;

&lt;p&gt;위 파일은 다음 명령어로 위치를 찾을 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;excludesfile&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jingyu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gitignore_global&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;파일을 열어서 ignore된 line을 수정하면 끝.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><category term="git" /><summary type="html">파일을 생성하거나 수정했는데 git 상태변화가 없을때</summary></entry><entry><title type="html">Virtual Memory</title><link href="http://localhost:4000/os/os-Virtual-Memory/" rel="alternate" type="text/html" title="Virtual Memory" /><published>2018-08-22T00:00:00+09:00</published><updated>2018-08-22T00:00:00+09:00</updated><id>http://localhost:4000/os/%5Bos%5D%20Virtual%20Memory</id><content type="html" xml:base="http://localhost:4000/os/os-Virtual-Memory/">&lt;h1 id=&quot;가상메모리&quot;&gt;가상메모리&lt;/h1&gt;

&lt;p&gt;가상메모리는 실제 메모리가 아닌 가상의 메모리를 관리하는 방법으로 멀티태스킹 운영체제에서 실제 메모리보다 큰 메모리를 제공 할 수 있다. 어느 시점에서 프로세스가 사용되는 부분은 일부분이며, 페이징이나 세그먼테이션 기법을 사용하여 실질적으로 필요한 부분만 메모리에 올려준다. 그러면 cpu는 연속적으로 메모리에 데이터를 가지고 있는것처럼 착각하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;demanding-page&quot;&gt;Demanding Page&lt;/h2&gt;

&lt;p&gt;실제로 필요할때 page를 메모리에 적재하는것&lt;/p&gt;

&lt;p&gt;현재 사용되는 부분은 물리 메모리에 올라와 있고 나머지 페이지는 &lt;strong&gt;backing store(swap area)&lt;/strong&gt;에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/pageReplacement.png&quot; alt=&quot;pageReplacement&quot; /&gt;&lt;/p&gt;

&lt;p&gt;페이지 테이블에 valid / invalid 비트를 두어 현재 물리 메모리에 올라와 있음을 체크한다. valid로 체크되어 있는 논리 주소는 바로 실제 주소로 변환된다. 하지만 invalid에 체크가 되어 있으면 MMU가 트랩을 발생 시키게 된다(&lt;strong&gt;“page fault”&lt;/strong&gt;). 이때 운영체제는 backing store에서 해당 페이지를 momory로 읽어온다(disk io). 이 후에 페이지 테이블에서 해당 페이지를 valid로 체크하고 다시 프로세스에게 cpu를 이양하여 작업을 계속하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/pageReplacement2.png&quot; alt=&quot;pageReplacement2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;page-replacement-algorithm&quot;&gt;Page replacement Algorithm&lt;/h2&gt;

&lt;p&gt;page fault가 발생하였는데 현재 메모리에 빈 공간이 없을 경우가 있다.&lt;/p&gt;

&lt;p&gt;page replacement algorithm은 어떤 프레임을 내쫒을지 결정하는 알고리즘으로 page-fault rate를 줄이는 것이 관건이다.&lt;/p&gt;

&lt;h3 id=&quot;optiaml-algorithm-최적-알고리즘&quot;&gt;Optiaml Algorithm (최적 알고리즘)&lt;/h3&gt;

&lt;p&gt;미래에 어떤 페이지가 올지 미리 알고 있는것을 가정한 것으로 가장 효율적인 알고리즘이다.&lt;/p&gt;

&lt;p&gt;실제로는 불가능하기 때문에 성능 측정용으로 사용한다.&lt;/p&gt;

&lt;p&gt;ex) 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;=&amp;gt; 6번 page fault 발생&lt;/p&gt;

&lt;h3 id=&quot;fifo-algorithm&quot;&gt;FIFO Algorithm&lt;/h3&gt;

&lt;p&gt;먼저 들어온 것을 먼저 내쫒는다.&lt;/p&gt;

&lt;h3 id=&quot;lru-least-recently-used-algorithm&quot;&gt;LRU (Least Recently Used) Algorithm&lt;/h3&gt;

&lt;p&gt;가장 오래전에 참조된 것을 내쫒는다.&lt;/p&gt;

&lt;p&gt;과거에 그 페이지가 자주 참조되었는지는 고려하지 않는다.&lt;/p&gt;

&lt;p&gt;가장 많이 사용되는 알고리즘 중 하나이다.&lt;/p&gt;

&lt;p&gt;ex) 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;=&amp;gt; 8번 page fault 발생&lt;/p&gt;

&lt;p&gt;LinkedList를 사용하여 구현하여 한줄로 세운다. 새로 참조되는 노드는 가장 줄의 가장 마지막으로 이동시키고 page fault가 발생할 경우 가장 첫 노드를 내쫒으면 된다. 시간복잡도 : O(1)&lt;/p&gt;

&lt;h3 id=&quot;lfu-least-frequently-used-algorithm&quot;&gt;LFU (Least Frequently Used) Algorithm&lt;/h3&gt;

&lt;p&gt;가장 적게 참조된 것을 내쫒는다.&lt;/p&gt;

&lt;p&gt;과거에 페이지의 빈도수를 계산하여 우선순위를 매긴다.&lt;/p&gt;

&lt;p&gt;LinkedList를 사용하여 구현하게되면 새로 참조되는 노드부터 마지막 노드까지 비교하여 이동시키기 때문에 O(n)의 시간 복잡도가 된다. 하지만 Heap을 사용하여 구현하면 O(logN)가 된다.&lt;/p&gt;

&lt;h3 id=&quot;clock-algorithm&quot;&gt;Clock Algorithm&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/clockAlgorithm.png&quot; alt=&quot;clockAlgorithm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;페이지들의 reference bit를 CirecularLinkedList로 구현하고 사용될때 1로 셋팅한다. bit를 1로 바꾸는 것은 하드웨어의 지원을 받고 0으로 바꾸는 것은 운영체제가 한다. 시계바늘이 한바퀴 돌면서 1인것은 0으로 셋팅하여 다음 방문까지 한번 더 기회를 주고 0인경우 페이지를 쫒아낸다. 내용이 수정된적이 있으면 modified bit(=dirty bit)을 1로 셋팅하여 1이면 디스크로 쫒아낼때 디스크 내용도 바꿔준다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*reference bit (= access bit) : 1은 최근에 사용됨, 0은 사용되지 않음&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;클럭 알고리즘은 NUR(Not Used Recently), NRU(Not Recently Used)라고도 불린다.&lt;/p&gt;

&lt;h2 id=&quot;thrashing&quot;&gt;Thrashing&lt;/h2&gt;

&lt;p&gt;메모리에 프로세스가 여러개가 올라와있는 경우 cpu utilization이 상승한다. 하지만 계속해서 프로세스가 메모리에 올라가게 되어 메모리의 한계치까지 도달하게 된다면 page-fault가 일어나기 시작한다. 결국에는 cpu가 일을 제대로 하지 못하고 페이지 교체만 처리하느라 cpu 이용률이 급격히 떨어지게 된다. 이와 같은 현상을 &lt;strong&gt;Thrashing&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;locality-of-reference&quot;&gt;Locality of reference&lt;/h3&gt;

&lt;p&gt;프로세스는 특정 시점에서 일정 장소만을 집중적으로 참조한다.&lt;/p&gt;

&lt;p&gt;집중적으로 참조되는 page들의 집합을 locality set이라고 한다.&lt;/p&gt;

&lt;p&gt;다음은 스레싱을 방지하는 알고리즘이다.&lt;/p&gt;

&lt;h3 id=&quot;working-set-model&quot;&gt;Working-set Model&lt;/h3&gt;

&lt;p&gt;한꺼번에 메모리에 올라와 있어야 하는 page의 집합을 &lt;strong&gt;working-set&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;Thrashing을 예방할 수 있다.&lt;/p&gt;

&lt;p&gt;현재 시점에서 n개의 과거페이지를 워킹셋으로 두고 메모리에 유지한다. page-fault가 발생하여 쫒겨날 경우 통째로 쫒겨나고 메모리에 올라올경우 워킹셋을 보장할 수 있을때만 통째로 올라온다.&lt;/p&gt;

&lt;h3 id=&quot;pff-page-fault-frequency&quot;&gt;PFF (Page Fault Frequency)&lt;/h3&gt;

&lt;p&gt;프로세스가 처음 시작되면 페이지폴트가 계속해서 발생하여 페이지 부재율이 매우 높다. 이 후에 어느정도 메모리에 페이지를 할당받으면 페이지 부재율은 낮아지게 되며 곡선을 그리며 내려오게 된다. 즉, 초반에는 페이지 부재율이 급격히 낮아지다가 점점 감소율이 적어지게 된다. PFF는 가장 효과적인 구간을 유지하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;페이지 부재율의 상한과 하한을 정하고 상한을 넘으면 frame을 더 할당하고 하한값 이하이면 할당 frame 수를 줄인다.&lt;/p&gt;

&lt;h2 id=&quot;page-size의-수&quot;&gt;Page Size의 수&lt;/h2&gt;

&lt;p&gt;페이지 사이즈를 감소시킬때 장단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 수 증가&lt;/li&gt;
  &lt;li&gt;페이지 테이블 크기 증가&lt;/li&gt;
  &lt;li&gt;내부 단편화 감소&lt;/li&gt;
  &lt;li&gt;page-fault시 더 많은 디스크io가 발생함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최근에는 큰 페이지 사이즈를 가지려고 하는 편이다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">Virtual Memory</summary></entry><entry><title type="html">Memory Management</title><link href="http://localhost:4000/os/os-Memory-Management/" rel="alternate" type="text/html" title="Memory Management" /><published>2018-08-20T00:00:00+09:00</published><updated>2018-08-20T00:00:00+09:00</updated><id>http://localhost:4000/os/%5Bos%5D%20Memory%20Management</id><content type="html" xml:base="http://localhost:4000/os/os-Memory-Management/">&lt;p&gt;컴퓨터는 cpu에서 논리주소를 읽고 실제 물리주소로 변환하는 작업을 한다.&lt;/p&gt;

&lt;p&gt;연속 할당 방식과 페이징 기법, 세그먼테이션 기법을 알아보자&lt;/p&gt;

&lt;h2 id=&quot;연속-할당-방식&quot;&gt;연속 할당 방식&lt;/h2&gt;

&lt;p&gt;프로그램을 구성하는 가상 메모리를 MMU를 통해 변화되어 통째로 할당되는 방식이다. 비교적 간단한 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/memoryconvert.png&quot; alt=&quot;memoryconvert&quot; /&gt;&lt;/p&gt;

&lt;p&gt;할당되는 과정에서 내부 단편화와 외부 단편화가 발생할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;First-fit : Size가 n 이상인 것 중 최초로 찾아지는 hole에 할당 -&amp;gt; 가장 빠르다.&lt;/li&gt;
  &lt;li&gt;Best-fit : Size가 n 이상인 가장 작은 hole을 찾아 할당 -&amp;gt; 정렬되지 않는 경우 시간이 오래걸림&lt;/li&gt;
  &lt;li&gt;worst-fit : 가장 큰 hole에 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;불연속-할당-방식-paging&quot;&gt;불연속 할당 방식 (paging)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;paging&lt;/strong&gt; : 프로세스를 일정 크기(4kb)의 페이지로 나누어 메모리에 할당하는 방식이다. 모든 페이지가 동일하기 때문에 빈 페이지(4kb) 보다 프로세스의 페이지(4kb)가 더 커서 발생하는 외부 단편화가 생기는 일은 없다. 하지만 프로세스가 4kb로 나누어 떨어지는 것을 보장할 수는 없기 때문에 내부 단편화가 발생할 가능성은 존재한다. (예를들어 마지막 페이지가 2kb를 차지할경우 2kb만큼의 내부 단편화가 생긴다.)&lt;/p&gt;

&lt;p&gt;페이징은 MMU대신에 페이지 테이블이 그 역할을 한다.&lt;/p&gt;

&lt;p&gt;프로세스의 논리적인 메모리는 페이지로 구성되어있고, 페이지 테이블을 통해 물리적 메모리의 어디에 할당되어 있는지 알 수 있다.&lt;/p&gt;

&lt;p&gt;cpu는 페이지 테이블과 offset을 가지고 페이지 테이블을 참조하여 실제 주소를 찾는다.&lt;/p&gt;

&lt;p&gt;페이지 테이블은 메모리에 상주하고 있다. 만약 해당 페이지에 접근을 하려면 페이지 테이블과 실제 데이터의 접근하므로 총  2번의 접근을 한다. 때문에 속도향상을 위해 &lt;strong&gt;TLB(Translation Look-aside Buffer)&lt;/strong&gt;라는 lookup 하드웨어 캐시를 사용하여 주소변환을 빠르게 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 테이블의 일부는 TLB캐시에 담아두고 cpu는 페이지 테이블에 접근하기 전에 TLB를 확인하고 있으면 실제 데이터에 접근한다.(메모리 1번 접근) 하지만 TLB에 없다면 똑같이 페이지 테이블에 접근하고 실제 데이터에 접근한다.(메모리 2번 접근)&lt;/li&gt;
  &lt;li&gt;TLB는 병렬적인 접근이 가능해서 페이지가 TLB에 존재하는지 검사하는 속도는 매우 빠르다.&lt;/li&gt;
  &lt;li&gt;프로세스가 context switch가 발생할때 TLB는 초기화된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-level-page-table&quot;&gt;2 Level Page Table&lt;/h3&gt;

&lt;p&gt;page테이블을 한 단계로만 쓰면 주소공간의 낭비가 매우 크기 때문에  2단계로 페이지를 구성한다.&lt;/p&gt;

&lt;p&gt;32비트 컴퓨터에서 하나의 프로세스는 2^32 크기 (4GB) 를 가질 수 있고, 4KB의 페이지로 나누게 되면 백만개의 페이지로 구성된다. 만약 하나의 페이지 테이블을 사용한다면 페이지 테이블의 크기는 백만 x 4B = 4M 의 크기를 가지게 된다. 즉, 각각의 프로세스는 4M의 페이지 테이플을 가지게 되므로 낭비가 매우 심하다고 할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 실제 프로세스의 메로리중 대부분의 공간은 사용하지 않는 공간일 수 있다. 하나의 페이지 테이블 엔트리만 사용한다면 사용되지 않는 부분도 비워둘 수 없다. 왜냐하면 나중에 사용하려고 할때 접근할 수 없기 때문이다. 2단계 페이지 테이블 기법은 사용하지 않는 부분은 outer-page table에 NULL로 셋팅하고 inner-page table에는 만들지 않으면 된다. 그렇게 되면 페이지 테이블의 크기를 크게 절약할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/2levelpage.png&quot; alt=&quot;2levelpage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/2levelpage2.png&quot; alt=&quot;2levelpage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;32비트 컴퓨터의 2단계 페이지의 logical address는 다음과 같이 구성된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page number1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page number2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page offset&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;4KB 페이지에서 몇번째 offset인지 구분하는 page offset은 몇 비트로 4KB를 구분할 수 있는지를 의미한다. 4KB = 2^12 이므로 12비트를 사용해서 구분이 가능하다.&lt;/li&gt;
  &lt;li&gt;page number2는 physical memory의 몇번째 프레임에 페이지가 위치하고 있는지를 의미한다. 즉 주소를 의미하므로 각 엔트리는 4B이다. 페이지 테이블 하나의 크기는 4KB이므로 4KB / 4B = 1K = 2^10 이므로 10비트를 사용해서 구분이 가능하다.&lt;/li&gt;
  &lt;li&gt;page number1은 총 32비트에서 (12 + 10) 을 뺀  10을 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 방식을 활용하여 다단계 페이지를 만들게 되면 공간을 크게 절약할 수 있지만 접근시간은 더 오래 걸린다는 단점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*사실 프로세스에서는 극히 일부분의 페이지만 사용한다고 한다. TLB를 활용하면 다단계 페이지 기법을 사용해도 TLB Hit율이 높기때문에 높은 속도를 유지한다고 한다.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;segmentation&quot;&gt;Segmentation&lt;/h2&gt;

&lt;p&gt;페이징 기법이 프로세스를 동일한 크기로 나누어 관리하는것과 다르게 세그먼테이션 기법은 의미단위(코드/데이터/스택)의 세그먼트로 나누어 구성한다.&lt;/p&gt;

&lt;p&gt;세그먼테이션 기법도 페이징과 비슷하게 주소변환을 한다. 하지만 세그먼테이션은 페이지와 다르게 크기가 일정하지 않기 때문에 세그먼트 테이블에는 물리주소의 프레임 번호와 함께 limit값도 담고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/segmentation.png&quot; alt=&quot;segmentation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;장점 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;보안 - 의미 단위로 구성되어 있기 때문에 접근권한을 통째로 줄 수 있어서 보안에 유용하다. (페이지는 코드 영역과 데이터 영역이 페이지의 크기만큼 딱 떨어지는 보장이 없기 때문에 힘들다)&lt;/li&gt;
  &lt;li&gt;공유 - 의미 단위로 구성되어 있기 때문에 같은 부분을 공유하기 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단점 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;세그먼트의 크기가 제각각이기 때문에 외부 단편화가 발생하여 메모리 낭비가 크다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;세그먼트의 구성이 많지 않기 때문에 현실적으로는 세그먼트기법을 사용하는 경우는 거의 없다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;segmentation-with-page&quot;&gt;Segmentation with Page&lt;/h3&gt;

&lt;p&gt;페이지와 세그먼테이션을 혼합하여 사용한다.&lt;/p&gt;

&lt;p&gt;두가지 기법의 장점을 살리고 단점을 극복한 방법이다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">Memory Management</summary></entry><entry><title type="html">Process Synchronization</title><link href="http://localhost:4000/os/os-Process-Synchronization/" rel="alternate" type="text/html" title="Process Synchronization" /><published>2018-08-13T00:00:00+09:00</published><updated>2018-08-13T00:00:00+09:00</updated><id>http://localhost:4000/os/%5Bos%5D%20Process%20Synchronization</id><content type="html" xml:base="http://localhost:4000/os/os-Process-Synchronization/">&lt;h2 id=&quot;race-condition&quot;&gt;race condition&lt;/h2&gt;

&lt;p&gt;공유자원에 대해서 여러 프로세스가 동시에 접근하는 상황을 말한다.&lt;/p&gt;

&lt;p&gt;사용자 프로그램 혹은 커널에서 공유 메모리에 있는 자원을 사용하다가 시스템콜 혹은 인터럽트가 발생하여 
다른 작업을 실행하는데 이전에 사용하던 자원을 사용하게 되면 일관성을 해치게 된다.&lt;/p&gt;

&lt;p&gt;예를들어 공유데이터 x가 있는데 프로세스 A는 &lt;code class=&quot;highlighter-rouge&quot;&gt;x = x + 1;&lt;/code&gt;  명령을 수행하고, 프로세스 B는 &lt;code class=&quot;highlighter-rouge&quot;&gt;x = x -1&lt;/code&gt; 명령을 수행한다.&lt;/p&gt;

&lt;p&gt;사실 컴퓨터에서는 저 명령어 한줄을 원자적으로 한번에 처리할 수 없다.&lt;/p&gt;

&lt;p&gt;실제로는&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reg1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;reg1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reg1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이런식으로 처리를 하게 되는데 A의 명령어 수행중  B의 인터럽트로 x를 변경하는 경우 일관성이 깨지는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;critical-section-problem&quot;&gt;Critical Section Problem&lt;/h2&gt;

&lt;p&gt;위 예제처럼 공유데이터를 접근하는 부분을 &lt;strong&gt;critical section&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;~~~&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// critical section
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~~~&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;u&gt;critical section&lt;/u&gt;을 피하는 방법을 소프트웨어적으로 해결하기 위해선 다음과 같은 원칙을 만족시켜야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Mutual Exclusion (상호배제) : 동시에 진입할 수 없다.&lt;/li&gt;
  &lt;li&gt;Progress (진행) : 진행이 안된다.&lt;/li&gt;
  &lt;li&gt;Bounded Waiting (유한대기) : 기다리는 시간이 유한해야 한다. (starvation을 막아야 한다)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Alogridm1&lt;/strong&gt; 1번 동시에 들어가는 경우를 해결&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// init turn
// process P0의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내턴이 아니면 waiting...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// process P1의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내턴이 아니면 waiting...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 경우 &lt;u&gt;critical secion&lt;/u&gt;에는 동시에 진입하는 경우는 해결하지만 한 프로세스가 &lt;u&gt;critical section&lt;/u&gt;에 진입할 필요가 없어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;turn&lt;/code&gt;을 바꿔놓지 않는다면 다른 프로세스는 영원히 못들어 가고 while만 뺑뺑이 돌게된다…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alogridm2&lt;/strong&gt; algo1의 문제를 해결&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// process P0의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// waiting...
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// critical section
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발 내림
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// process P1의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// waiting...
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// critical section
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발 내림
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;u&gt;critical secion&lt;/u&gt;에 진입하기 전에 깃발을 들고 작업 후 깃발을 내린다. 그러면 다른 프로세스는 상대의 깃발이 들려있을 경우 while을 돌며 대기하다가 깃발이 내려갈경우 진입하게 된다. 그러나 &lt;code class=&quot;highlighter-rouge&quot;&gt;flag[0] = true; // 내 깃발을 듬&lt;/code&gt; 에서 인터럽트가 발생해서 다른 프로세스가 실행 될 경우 두 프로세스가 깃발을 동시에 들게 되어 아무도 진입하지 못하는 문제가 발생한다. 결국 동시성은 해결하지만 서로 눈치만 보다 진행이 되지 않는 경우가 생길 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alogridm3&lt;/strong&gt; algo1과 2의 문제 해결 (Peterson의 알고리즘)&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// process P0의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 상대에게 턴을 넘김
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// waiting...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// process P1의 코드
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 상대에게 턴을 넘김
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// waiting...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;turn이라는 변수를 두어서 2와 같이 서로 눈치만 보는 경우를 해결하였다.&lt;/p&gt;

&lt;p&gt;깃발을 동시에 들더라도 turn은 0아니면 1의 값을 가지게 되므로 두 프로세스 중 하나만 &lt;u&gt;critical section&lt;/u&gt;에 진입하게 된다.&lt;/p&gt;

&lt;p&gt;여기서 이 두 코드의 순서를 바꾸게 되면 제대로 동작하지 않으니 유의하자.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내 깃발을 듬
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 상대에게 턴을 넘김
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;간단해 보이지만 생각보다 잘 짜여진 코드인것 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;그러나&lt;/strong&gt; &lt;em&gt;Peterson의 알고리즘&lt;/em&gt;으로 제대로 동작하는 것은 보장하게 되지만 비효율적인 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;왜냐하면 &lt;u&gt;critical section&lt;/u&gt;에 진입한 프로세스가 있을경우 다른 프로세스는 cpu를 획득해봤자 while문만 계속 돌면서 cpu를 낭비하기 때문이다. 이를 &lt;strong&gt;Spin Lock&lt;/strong&gt;이라고 한다. 	&lt;em&gt;*spin lock : 계속 cpu와 메모리를 쓰면서 wait (busy-waiting)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;사실 Critical Section 문제를 해결하기 위해 하드웨어 지원을 받는다면 더 쉽게 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;하드웨어적으로 &lt;strong&gt;Test &amp;amp; Modify&lt;/strong&gt;를 &lt;u&gt;atomic&lt;/u&gt;하게 수행하게 된다면 간단히 해결된다.&lt;/p&gt;

&lt;p&gt;즉, 앞의 알고리즘처럼 flag와 turn을 셋팅하고 while에서 검사하여 진행하는 것이 아니라 읽고 쓰는 작업을 Test_and_Set() 이라는 하드웨어 지원 함수로 한번에 수행하면 된다는 것이다. 이렇게 &lt;u&gt;atomic&lt;/u&gt;하게 수행된다면 어느 순간에 인터럽트 되더라도 일관성을 유지할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test_and_Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 락을 걸면서 바로 critical section에 진입함
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// ciritical section
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;semaphores&quot;&gt;Semaphores&lt;/h2&gt;

&lt;p&gt;세마포어는 앞서 살펴본 방식들을 추상화 시킨것이다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// while(S&amp;lt;=0); S--;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// S++;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;P 연산은 critical section에 진입할때 S를 감소시키고 V 연산은 자원을 다시 내놓는 작업을 한다.&lt;/p&gt;

&lt;p&gt;세마포어는 자원을 여러 프로세스가 점유할 수 있는 Counting semaphore와 Binary semaphore가 있다.&lt;/p&gt;

&lt;p&gt;Binary semaphore는 세마포어가 하나인 경우(0 or 1만 가질 수 있는 세마포어)를 말하며 앞에서 본 Mutual Exclusion의 줄여 &lt;strong&gt;mutex&lt;/strong&gt;라고도 한다.&lt;/p&gt;

&lt;p&gt;세마포어를 사용하여 critical section문제를 해결하는 코드는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// process P1의 코드
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이번에는 세마포어를 사용하여 SpinLock문제를 해결해보자.&lt;/p&gt;

&lt;p&gt;앞의 세마포어 S는 단순히 자원의 갯수를 의미하지만 세마포어 구조체를 확장하여 Process 리스트를 추가하고 critical section에 진입하지 못하는 프로세스들을 줄세우게 한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이러한 방식은 &lt;strong&gt;block&amp;amp;wake up&lt;/strong&gt; 방식이라고 하면 &lt;em&gt;block()&lt;/em&gt;과 &lt;em&gt;wakeup()&lt;/em&gt; 을 지원한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;block()&lt;/em&gt;은 해당 프로세스의 PCB를 세마포어에 대한 List에 추가한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;wakeup()&lt;/em&gt;은 block된 프로세스의 PCB를 레디큐로 옮긴다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* 
S.value--;
if(S.value &amp;lt; 0) {
add to S.L;
block();
}
*/&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
S.value++;
remove P from S.L;
wakeup(P);
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;프로세스의 상태도에 나와있는 공유메모리의 큐에 잠자게 하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/processState.png&quot; alt=&quot;processState&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 &lt;strong&gt;busy-waiting&lt;/strong&gt; 방식보다 &lt;strong&gt;block&amp;amp;wake-up&lt;/strong&gt; 방식이 더 효율적이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;세마포어를 사용할때 DeadLock과 Starvation문제가 발생할 가능성이 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DeadLock&lt;/strong&gt; : 둘 이상의 프로세스가 서로 상대방이 가진 자원을 기다리며 block된 상태.&lt;/p&gt;

&lt;p&gt;예를들어 P0이 S를 획득하고, P1이 Q를 획득한 상황에서 P0이 Q를 기다리고 P1이 S를 기다린다면 영원히 서로 기다리게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;세마포어의 단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;코딩하기 힘들다 -&amp;gt; P연산과 V연산을 쌍으로 정확히 코딩해야한다&lt;/li&gt;
  &lt;li&gt;정확성 입증이 힘들다&lt;/li&gt;
  &lt;li&gt;자발적 협력이 필요하다&lt;/li&gt;
  &lt;li&gt;한번의 실수가 전체 시스템에 치명적이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;나중에 모니터를 사용해서 단점을 개선할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;동기화에-관련된-문제들&quot;&gt;동기화에 관련된 문제들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Bounded Buffer Problem (Producer-Consumer Problem)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;유한한 버퍼를 두고 생산자와 소비자 사이에서 발생할 수 있는 문제이다.&lt;/p&gt;

&lt;p&gt;생산자 프로세스는 버퍼가 비어있어야 데이터를 생성할 수 있기 때문에 버퍼에 빈 공간이 있을때까지 대기한다.&lt;/p&gt;

&lt;p&gt;소비자 프로세스는 버퍼가 차 있어야 데이터를 읽을 수 있기 때문에 버퍼에 데이터가 있을때까지 대기한다.&lt;/p&gt;

&lt;p&gt;당연히 공유메모리에 여러 프로세스가 접근하기 때문에 동기화가 이루어져야하고, busy-waiting 도 해결해야 한다.&lt;/p&gt;

&lt;p&gt;세마포어를 사용하여 해결하기 위해 두개의 카운팅 세마포어와 뮤텍스가 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semaphore full = 0, empty = n, mutex = 1;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Producer
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;produce&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 자원을 생산
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 빈 버퍼를 얻는다 (n--)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 다른 생산자나 소비자의 접근을 막는 lock
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내용이 들어있는 버퍼를 하나 추가
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Consumer
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내용이 들어있는 버퍼를 얻는다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 자원을 소비
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 빈 버퍼를 하나 추가
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 자원을 소비
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Readers Writers Problem&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현실세계에서 DB의 데이터 접근/쓰기 문제와 비슷하다. 한 프로세스가 write중일때 다른 프로세스는 접근할 수 없지만 Read는 동시에 해도 상관없다. 즉, Reader들에 대해서는 동시접근을 허용하며, Writer들에게는 배타적 접근을 지원한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 현재 DB에 접근하는 Reader의 수
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// readcount의 상호배타적 접근을 위한 mutex
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Writer
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;writing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Reader
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// readcount 통제
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Writer의 접근을 막는 lock (만약 1이 아니라 1보다 크다면 이전에 이미 lock이 걸려있음)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Writer의 접근을 허용
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;하지만 Reader가 끊임없이 read를 시도하면 Writer는 Starvation이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;때문에 일정시간을 기준으로만 Reader를 받고 Writer에게 기회를 주는 방식으로 해결할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Dining Philosophers Problem (식사하는 철학자 문제)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다섯명의 철학자가 원탁에 앉아 식사하는 상황에서 발생하는 문제이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/philosophers.png&quot; alt=&quot;philosophers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다섯명의 철학자가 동시에 왼쪽 젓가락을 잡는 경우 DeadLock이 발생한다.&lt;/p&gt;

&lt;p&gt;해결 방법으로는 젓가락을 집기 전에 양쪽이 가능한지 먼저 확인한 뒤 밥을 먹게 하는 방법이 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 양옆이 eating상태가 아닌지 체크하고 내 상태를 eating으로 만든다
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 양옆을 깨워준다
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 각각의 Philosopher 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;think&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;monitor&quot;&gt;Monitor&lt;/h2&gt;

&lt;p&gt;공유 데이터에 대한 안전한 공유를 보장하기 위해 고급언어에서 지원하는 도구&lt;/p&gt;

&lt;p&gt;이전의 세마포어에의 단점을 개선하고자 나온것이 모니터이다.&lt;/p&gt;

&lt;p&gt;모니터는 공유데이터와 함께 접근하기 위한 operations를 제공한다. 즉, 공유데이터를 접근하기 위해 프로그래머가 직접 lock을 걸고 풀고 할 필요없이 제공하는 operation을 사용함으로써 그 책임을 모니터에게 이양시킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os/monitor.png&quot; alt=&quot;monitor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모니터에는 condition변수를 두어 세마포어에서 사용한 block&amp;amp;wake-up 방식으로 구현한 큐처럼 관리한다.&lt;/p&gt;

&lt;p&gt;Condition variable은 큐에 줄을 세우는 wait()와 깨우는 signal() 연산을 제공한다.&lt;/p&gt;

&lt;p&gt;동기화에 관한 문제를 모니터를 사용해 해결해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Bounded Buffer Problem (Producer-Consumer Problem)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;monitor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bounded_buffer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 공유데이터가 모니터 안에 정의
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 버퍼에 남은 공간이 없으면
&lt;/span&gt;    		&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 기다린다. 나중에 소비자가 signal()로 빈버퍼가 생김을 알리면 깨어남
&lt;/span&gt;    	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 데이터 추가
&lt;/span&gt;    	&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 버퍼가 가득 차면
&lt;/span&gt;    		&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;세마포어처럼 P연산 V연산을 쓰지 않고 일반적인 상식에 맞게 생산자는 버퍼에 빈공간 있는지 체크하고 없으면 wait()를 한다.&lt;/p&gt;

&lt;p&gt;따라서 프로그래머 입장에서는 자연스럽게 코딩할 수 있기 때문에 실수가 적어지게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Dining Philosophers Problem (식사하는 철학자 문제)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;monitor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dining_philosopher&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 양옆이 eating상태가 아닌지 체크하고 내 상태를 eating으로 만든다
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// test후에 불가능하면 잠재운다
&lt;/span&gt;        	&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    	&lt;span class=&quot;c1&quot;&gt;// 양옆을 깨워준다
&lt;/span&gt;    	&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
    		 &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
    		 &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    		&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    		&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 각각의 Philosopher 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;think&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;deadlock&quot;&gt;DeadLock&lt;/h2&gt;

&lt;p&gt;둘 이상의 프로세스가 서로 상대방이 가진 자원을 기다리며 block된 상태.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DeadLock 발생 4가지 조건&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Mutual exclusion (상호 배제)&lt;/strong&gt; : 매순간 하나의 프로세스만 자원을 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No preemption (비선점)&lt;/strong&gt; : 자원을 강제로 빼앗기지 않음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Hold and wait (보유 대기)&lt;/strong&gt; : 다른 자원을 기다릴때 보유자원을 내놓지 않음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Circular wait (환형 대기)&lt;/strong&gt; : 자원을 기다리는 프로세스간 사이클이 형성되어야 함&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다음과 같은 네가지 조건이 모두 성립할 경우에 DeadLock이 발생한다. 다시말하면 네가지중 하나만 제거를 할 경우 해결 가능하다.&lt;/p&gt;

&lt;p&gt;1번을 제거할 경우 동기화가 제대로 동작하지 않기 때문에 적절하지 않다.&lt;/p&gt;

&lt;p&gt;2번을 제거하려면 선점으로 만들어주는 것인데 이는 프린터가 출력되는 도중 여러 내용이 섞이는 것과 같기 때문에 적절치 않다.&lt;/p&gt;

&lt;p&gt;3번을 만족하지 않는다는 것은 모든 자원이 충족될 경우에만 일을 하기 때문에 starvation이 발생할 수 있고 비효율적이다.&lt;/p&gt;

&lt;p&gt;4번을 제거하는 것이 가장 적절한 방법으로 식사하는 철학자 문제와 같이 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Banker’s algoridm :&lt;/strong&gt; 공유데이터에 복수의 자원이 있을경우 deadlock을 해결하는 방법&lt;/p&gt;

&lt;p&gt;unsafe한 상황이 처하지 않도록 유지한다.&lt;/p&gt;

&lt;p&gt;현재 할당된 자원과 최대요청자원, 가능한 자원, 필요한 자원을 표로 나타내어 가용자원이 추가요청자원을 충족할 수 있을경우만 자원을 주어서 safe한 상태를 유지한다. 각각의 프로세스들의 최대요청 자원을 사전에 알고있어야 한다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">Process Synchronization</summary></entry><entry><title type="html">xcode Use of undeclared type 에러</title><link href="http://localhost:4000/ios/xcode-Use-of-undeclared-type-%EC%97%90%EB%9F%AC/" rel="alternate" type="text/html" title="xcode Use of undeclared type 에러" /><published>2018-08-07T00:00:00+09:00</published><updated>2018-08-07T00:00:00+09:00</updated><id>http://localhost:4000/ios/xcode%20%22Use%20of%20undeclared%20type%22%20%EC%97%90%EB%9F%AC</id><content type="html" xml:base="http://localhost:4000/ios/xcode-Use-of-undeclared-type-%EC%97%90%EB%9F%AC/">&lt;h2 id=&quot;xcode-use-of-undeclared-type-에러-해결법&quot;&gt;Xcode “Use of undeclared type” 에러 해결법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018-08-07-post1/1.png?raw=true&amp;quot;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트 빌드는 되는데 계속해서 오류가 발생하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;실행이 잘 되기 때문에 그냥 냅두고 계속 진행했지만 자동완성이 먹히지 않고 거슬려서 이유를 찾아보았다.&lt;/p&gt;

&lt;p&gt;원인은 Build Phases에 해당 소스가 추가되지 않았기 때문이었다.&lt;/p&gt;

&lt;p&gt;프로젝트 타겟 - Build Phases 에서 +버튼을 눌러 해당 소스를 추가해주면 해결된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018-08-07-post1/2.png?raw=true&amp;quot;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행하는데 문제가 없었기 때문에 원인을 찾기 힘들었다…&lt;/p&gt;

&lt;p&gt;타겟에 추가가 되지 않았던 이유는 다른 프로젝트에 있는 소스파일을 가져오면서 제대로 설정되지 않았던 것 같다.&lt;/p&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">Use of undeclared type</summary></entry><entry><title type="html">AWS Lamda 사용기</title><link href="http://localhost:4000/aws/lamda%EC%82%AC%EC%9A%A9%EA%B8%B0/" rel="alternate" type="text/html" title="AWS Lamda 사용기" /><published>2018-07-27T00:00:00+09:00</published><updated>2018-07-27T00:00:00+09:00</updated><id>http://localhost:4000/aws/lamda%EC%82%AC%EC%9A%A9%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/aws/lamda%EC%82%AC%EC%9A%A9%EA%B8%B0/">&lt;h2 id=&quot;lamda를-써보자&quot;&gt;Lamda를 써보자&lt;/h2&gt;</content><author><name>Jingyu</name><email>kjingyu91@gmail.com</email></author><summary type="html">How to use AWS Lamda.</summary></entry></feed>